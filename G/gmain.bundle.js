// gmain.bundle.js - All-in-one compatible bundle for GoddeSpark

// --- Firebase CDN Imports ---
import { getFirestore, collection, doc, setDoc, deleteDoc, onSnapshot, getDoc, getDocs, query, limit, runTransaction, increment, collectionGroup, orderBy, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getStorage, ref, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

// --- Start of app-config.js ---
const appInfo = { title: "å¥³ç¥æ…¾è¦‹GoddeSpark", version: "1.6.62", footer: { copyrightYear: "2025", authorName: "LayorX", authorLink: "https://layorx.github.io" } };
const serviceKeys = { firebaseConfig: { apiKey: "AIzaSyDbWa8TWru1J048WK8msVBaC9JhhhtuhJw", authDomain: "goddess-chance.firebaseapp.com", projectId: "goddess-chance", storageBucket: "goddess-chance.appspot.com", messagingSenderId: "440990936442", appId: "1:440990936442:web:37d864cd13112f14913ac3", measurementId: "G-3HCCT2PFXX" }, defaultApiKey: "AIzaSyAZUc69ryBPqw0Ss2ZV-f4Jg5kP3VjDd0c", formspreeUrl: "https://formspree.io/f/xnnzgpdn" };
const dbCollectionNames = { users: 'users', publicGoddesses: 'public-goddesses', dailyTasks: 'dailyTasks', statistics: 'statistics', userStats: 'userStats', favorites: 'favorites', status: 'status' };

// --- Start of game-config.js ---
const randomNicknames = [ "Dæ§½å¥³ç¥å®˜", "æ³¢å¤šé‡çµå†°", "å‰æ¾¤æ˜æ­¥å…µ", "æ–æ¡¿ä¸æ˜¯é€™æ¨£ç”¨çš„", "ä¸‰ä¸Šæ‚ äºåŠ›å±±å¤§", "å–®æ‰‹ç©è¼”åŠ©", "å¥‡æ€ªçš„çŸ¥è­˜å¢åŠ äº†", "æœ¬æ–¥ä½†å¤§", "å¤©ä½¿èŒæ–°", "å°ˆæ¥­è£œé­”å¸«", "æ²³åŒ—å½©èŠ±éŒ¢", "ä¸€éµç¹³æ¢°", "è–å…‰ä¹Ÿæ²»ä¸äº†ä½ ", "æ¥“å¯æ†äº†", "æ©‹æœ¬æœ‰ç¢¼", "æ˜æ—¥èŠ±é¨å…µ", "å…¨æœæˆ‘æœ€å©†", "é¡¯å¡åœ¨ç‡ƒç‡’", "æ™‚é–“ç®¡ç†å¤§å¸«", "å¤šäººé‹å‹•", "ä½ è€å©†çœŸå¥½ç”¨", "ç›¸æ¾¤å—æ³¢ç£", "å¤§æ©‹æœªä¹…ç­‰äº†", "æ«»ç©ºæ¡ƒå¤ªéƒ", "ç¥å®®å¯ºåŠ©æˆ‘", "é€™é¡Œæˆ‘æœƒ", "ä¸å¯ä»¥è‰²è‰²", "å°å­©å­æ‰åšé¸æ“‡", "äººé¡é«˜å“è³ªå¥³æ€§", "èº«é«”å¾ˆèª å¯¦", "è¼¸å‡ºå…¨é æŠ–", "é€²æ“Šçš„å·¨ä¹³", "æ³•æ–ä¸æ˜¯é‚£æ¨£ç”¨", "å¥¶é‡å³æ˜¯æ­£ç¾©", "åé¨çµ¦å¦³é¨", "æ•—çŠ¬å¥³ç¥", "ç•°ä¸–ç•Œè½‰ç”Ÿå¥³ç¥", "è‚¥å®…å¿«æ¨‚å§¬", "æˆ‘çš„å¾ˆå¤§ä½ å¿ä¸€ä¸‹", "çµ•å°é ˜åŸŸ", "æ±‚ä½›ä¸å¦‚æ±‚æˆ‘", "ç´—å€‰çœŸç—›", "æ¶¼æ£®ç²å¤¢éŠ", "æˆ‘å…ˆç¹³æ¢°æŠ•é™", "å£äº†ï¼Œæˆ‘è£çš„", "è€å¸å§¬å¸¶å¸¶æˆ‘", "é›»å­é›å¥³ç¥", "è§€éŸ³å…µæ”¶å®¹æ‰€", "å¥³ç¥ä¹ŸæœƒèŠ­æ¯”Q", "ä¸Šä¸Šä¸‹ä¸‹å·¦å³å·¦å³" ];
const announcementSettings = { enabled: true, checkLocalStorage: true, pages: [ { title: "ğŸ‰ æ‰­è›‹ç‹‚æ­¡ & æ‡¸è³çµäººè¨ˆç•«ï¼ ğŸ‰", message: `<p class="mb-4">Heyï¼å„ä½ç¥ç´šè£½é€ å¸«ï¼æº–å‚™å¥½è¿æ¥ä¸€å ´éˆé­‚çš„é¢¨æš´äº†å—ï¼Ÿ</p><p class="mb-3"><strong>ã€é™æ™‚æ‰­è›‹å¤§æ”¾é€ï¼ã€‘</strong><br>æ¯æ—¥æ‰­è›‹æ¬¡æ•¸ç˜‹ç‹‚é£†å‡åˆ° <strong>20 æ¬¡</strong>ï¼å¿«ä¾†çœ‹çœ‹èª°æ˜¯çœŸæ­£çš„å¤©é¸ä¹‹äººï¼</p><p class="mb-3"><strong>ã€Bug æ‡¸è³ä»¤ï¼ã€‘</strong><br>ç™¼ç¾ä»»ä½• Bug æˆ–é¬¼é»å­ï¼Œé¦¬ä¸Šå›å ±ï¼Œè‡³å°‘ <strong>10 æ¬¡</strong> æ‰­è›‹æ©Ÿæœƒç›´æ¥å…¥å¸³ï¼</p><p><strong>ã€å¥³ç¥æ˜Ÿæ¢è¨ˆç•«ï¼ã€‘</strong><br>æˆåŠŸåˆ†äº«ä½ çš„å¥³ç¥åˆ°å„å¤§ç¤¾ç¾¤ï¼Ÿå¿«ä¾†å¡«å¯«<a href="https://forms.gle/JXdobEdAa8is2wyR6" target="_blank" class="font-bold text-amber-300 hover:underline">>>>é€™å€‹ç¥ç§˜è¡¨å–®<<<</a>ï¼Œè­‰æ˜ä½ çš„è²¢ç»ï¼Œæˆ‘å€‘å°‡ç”¨è‡³å°‘ <strong>30 æ¬¡</strong> æ‰­è›‹æ©Ÿæœƒæ·¹æ²’ä½ ï¼</p>` }, { title: `ğŸ”§ ç‰ˆæœ¬ v${appInfo.version} æ›´æ–°è³‡è¨Š ğŸ”§`, message: `<p class="mb-3">æˆ‘å€‘å¾ˆé«˜èˆˆå¸¶ä¾†é€™æ¬¡çš„æ›´æ–°ï¼Œä¸»è¦æ–°å¢äº†ç¤¾ç¾¤äº’å‹•åŠŸèƒ½ï¼š</p><ul class="list-disc list-inside space-y-2"><li><strong>å¥³ç¥é‡è¦‹å‡ç´šï¼š</strong>æ›´å¤šå…ƒåŒ–ï¼Œé™ä½æ•æ„Ÿå°é–(ä½¿ç”¨ç™½å¤©é¢¨æ ¼æ›´ä¸å®¹æ˜“)ã€‚</li><li><strong>å…¨æ–°ã€Œæ’è¡Œæ¦œã€é é¢ï¼š</strong>ç¾åœ¨ä½ å¯ä»¥å¾ä¸»é é€²å…¥æ¦®è­½æ®¿å ‚ï¼ŒæŸ¥çœ‹å„è·¯å¥½æ‰‹çš„æ’åï¼</li><li><strong>æ‰­è›‹å¡ç‰‡å„ªåŒ–ï¼š</strong>ç¾åœ¨æŠ½å¡æ™‚æœƒç›´æ¥é¡¯ç¤ºè©²å¥³ç¥çš„å—æ­¡è¿ç¨‹åº¦ï¼ˆè®š/å€’è®šæ•¸ï¼‰ã€‚</li><li><strong>æš±ç¨±ç³»çµ±å¯¦è£ï¼š</strong>ä½ å¯ä»¥åœ¨ã€Œå€‹äººåŒ–è¨­å®šã€ä¸­è¨­å®šä½ çš„å°ˆå±¬æš±ç¨±ï¼Œå®ƒå°‡æœƒé¡¯ç¤ºåœ¨æ’è¡Œæ¦œå’Œä¸»é ä¸Šã€‚</li><li><strong>UI/UX å„ªåŒ–ï¼š</strong>ä¿®å¾©äº†æ•¸å€‹å·²çŸ¥çš„ Bugï¼Œä¸¦å°ä»‹é¢é€²è¡Œäº†å¾®èª¿ï¼Œæå‡æ•´é«”ä½¿ç”¨é«”é©—ã€‚</li></ul><p class="mt-4">æ„Ÿè¬æ‚¨çš„æ”¯æŒï¼Œç¥æ‚¨éŠæˆ²æ„‰å¿«ï¼</p>` } ] };
const gameSettings = { dailyLimits: { generateOne: 20, generateFour: 2, gacha: 20, tts: 3, }, gachaStreakGoal: 2, gachaQueryLimit: 100, dislikeMilestones: { 1: "ã€Œä¸€é“è³ªç–‘çš„ç›®å…‰æŠ•ä¾†...ã€ (ç¬¬ä¸€ç¥¨)", 3: "ã€Œäººç¾¤ä¸­é–‹å§‹å‡ºç¾ç«Šç«Šç§èª...ã€ (ç¬¬ä¸‰ç¥¨)", 10: "ã€Œå¥³ç¥çš„ç¥æ€§ä¼¼ä¹ç”¢ç”Ÿäº†å‹•æ–ï¼ã€ (ç¬¬åç¥¨)", } };
const userStatsStructure = { likes: 0, unlikes: 0, shares: 0, gachaDraws: 0, gachaDislikes: 0, generateOne: 0, generateFour: 0, apiImports: 0, storyGenerations: 0, ttsGenerations: 0, totalGenerations: 0, };
const imageSettings = { resizedSuffix: '_200x300', resizedExtension: '.jpeg' };
const apiSettings = { imageGenerationRetries: 3, imageGenerationDelay: 1000, ttsVoice: "Sulafat", prompts: { imagePrefix: "masterpiece, best quality, ultra-detailed, photorealistic, 8k, sharp focus, detailed beautiful face.", imageSuffix: "aspect ratio 2:3, raw style.", negativePrompt: "ugly, blurry, bad anatomy, disfigured, poorly drawn face, mutation, mutated, extra limb, dull eyes, bad hands, missing fingers, low quality, jpeg artifacts, text, watermark, signature, cartoon, 3d, deformed.", story: (title, description) => `ä»¥ç¹é«”ä¸­æ–‡ï¼Œç‚ºä¸€å¼µé¢¨æ ¼ç‚ºã€Œ${title}ã€çš„å¥³æ€§ç…§ç‰‡èåˆ${description}ï¼Œå¯«ä¸€æ®µç´„150å­—çš„çŸ­ç¯‡æ•…äº‹æˆ–æƒ…å¢ƒæè¿°ã€‚è«‹ç”¨å……æ»¿æƒ³åƒåŠ›ä¸”æ„Ÿæ€§çš„ç­†è§¸ï¼Œæè¿°å¥¹çš„èƒŒæ™¯ã€å¿ƒæƒ…æˆ–ä¸€å€‹æ­£åœ¨ç™¼ç”Ÿçš„ç¬é–“ã€‚`, tts: (text) => `Say in a gentle and alluring female voice: ${text}` } };
const uiSettings = { enableLoadingAnimation: true, hideLoadingOnConnect: false, loadingScreenDuration: 3000, previewImages: [ 'gimages/g/g1.jpg', 'gimages/g/g2.jpg', 'gimages/g/g3.jpg', 'gimages/g/g4.jpg', 'gimages/g/g5.jpg', 'gimages/g/g6.jpg', 'gimages/g/g7.jpg', 'gimages/g/g8.jpg', 'gimages/g/g9.jpg' ], loadingSilhouettes: [ 'gimages/g/g1.jpg', 'gimages/g/g2.jpg', 'gimages/g/g3.jpg', 'gimages/g/g4.jpg', 'gimages/g/g5.jpg', 'gimages/g/g6.jpg', 'gimages/g/g7.jpg', 'gimages/g/g8.jpg', 'gimages/g/g9.jpg', 'gimages/g/g10.jpg', 'gimages/g/g11.jpg', 'gimages/g/g12.jpg' ], loadingPetalCount: 60, cardRevealDelay: 1, loadingAnimationStep: 1, slideshowTransitionSpeed: 250, swipeThreshold: 50, messageBoxTimeout: 3000, };
const uiMessages = { settingsModal: { title: "å€‹äººåŒ–è¨­å®š", imageQualityTitle: "åœ–ç‰‡é¡¯ç¤ºå“è³ª", qualityThumbnail: "ç¸®åœ–å„ªå…ˆ (é è¨­)", qualityThumbnailDesc: "å„ªå…ˆè¼‰å…¥ç¸®åœ–ï¼Œé»æ“Šå¾Œé¡¯ç¤ºåŸåœ–ï¼Œé€Ÿåº¦æœ€å¿«ã€‚", qualityOriginal: "åŸåœ–å„ªå…ˆ", qualityOriginalDesc: "æ‰€æœ‰åœ–ç‰‡ç›´æ¥è¼‰å…¥é«˜è§£æåº¦åŸåœ–ï¼Œç•«è³ªæœ€ä½³ä½†è¼ƒè€—æµé‡ã€‚", settingSaved: "è¨­å®šå·²å„²å­˜ï¼", nicknameTitle: "æ‚¨çš„æš±ç¨±", nicknamePlaceholder: "è«‹è¼¸å…¥æ‚¨å–œæ­¡çš„æš±ç¨±...", nicknameSave: "å„²å­˜", }, moreOptions: { ranking: "ğŸ† æ’è¡Œæ¦œ", settings: "âš™ï¸ å€‹äººåŒ–è¨­å®š", announcement: "ğŸ“¢ æŸ¥çœ‹å…¬å‘Š", about: "é—œæ–¼ä½œå“", contact: "è¯çµ¡æˆ‘ (å ±éŒ¯ã€å»ºè­°)", apiKey: "åŒ¯å…¥ Gemini API Key", }, announcement: { dontShowToday: "ä»Šå¤©ä¸å†é¡¯ç¤º" }, loading: { connecting: "æ­£åœ¨é€£æ¥é›²ç«¯...", summoning: "æ­£åœ¨å¾é›²ç«¯ç¥æ®¿å¬å–šå¥³ç¥...", starting: "é‚‚é€…å³å°‡é–‹å§‹..." }, gachaModalTitle: "å‘½é‹çš„é‚‚é€…", storyModalTitle: "å¥³ç¥çš„ç¯‡ç« ", buttons: { generateOne: "é‡è¦‹ä¸€ä½", generateFour: "é‡è¦‹å››ä½", favorites: "å¥³ç¥æ®¿å ‚", gacha: "å¥³ç¥æ‰­è›‹ ğŸ°", gachaDraw: "å¬å–š", ttsPlay: "è†è½æ•…äº‹", ttsStop: "åœæ­¢æ’­æ”¾", ttsLimit: "æ˜æ—¥å†ä¾†" }, generateLimit: { title: "ä»Šæ—¥éˆæ„Ÿå·²è€—ç›¡", message: "å…è²»ç”Ÿæˆæ¬¡æ•¸å·²ç”¨å®Œã€‚æ‚¨å¯ä»¥é»æ“Šã€Œæ›´å¤šé¸é …ã€åŒ¯å…¥è‡ªå·±çš„ Gemini API Key ä¾†ç¹¼çºŒç„¡é™æš¢éŠï¼" }, favorites: { emptyTitle: "æ®¿å ‚é‚„æ˜¯ç©ºçš„", emptySubtitle: "å¿«å»æ”¶è—æ‚¨å¿ƒå„€çš„å¥³ç¥å§ï¼", empty: "æ‚¨çš„å¥³ç¥æ®¿å ‚é‚„æ˜¯ç©ºçš„å–”ï¼", addSuccess: "æ”¶è—æˆåŠŸï¼", addFailure: "æ”¶è—å¤±æ•—", removeSuccess: "å·²å¾æ®¿å ‚ç§»é™¤ã€‚", removeFailure: "å–æ¶ˆæ”¶è—å¤±æ•—", uploading: "æ­£åœ¨ä¸Šå‚³è‡³é›²ç«¯...", shareFirst: "è«‹å…ˆæ”¶è—æ­¤å¥³ç¥æ‰èƒ½åˆ†äº«ï¼" }, gacha: { placeholder: "é»æ“Šä¸‹æ–¹æŒ‰éˆ•ï¼Œé‡è¦‹ä¸€ä½ä¾†è‡ªä»–äººå®‡å®™çš„å¥³ç¥", drawFailed: "å¬å–šå¤±æ•—", poolEmpty: "çæ± æ˜¯ç©ºçš„ï¼å¿«å»åˆ†äº«ä¸€äº›å¥³ç¥å§ï¼", alreadyShared: "é€™ä½å¥³ç¥å·²ç¶“åœ¨å…¬é–‹æ®¿å ‚ä¸­äº†ï¼", shareSuccess: "åˆ†äº«æˆåŠŸï¼ç²å¾—ä¸€æ¬¡é¡å¤–å¬å–šæ©Ÿæœƒï¼", comingSoon: "é‚„åœ¨ã€Œæ¿•ã€å·¥ä¸­... æ•¬è«‹æœŸå¾…ï¼", gachaZeroHint: "éˆé­‚çŸ³ç”¨å…‰äº†ï¼Ÿåˆ†äº«æ®¿å ‚ä¸­çš„å¥³ç¥ã€æˆ–å›å ± Bug/å»ºè­°éƒ½èƒ½ç²å¾—è£œå……ï¼Œä¹Ÿå¯ä»¥ç­‰å¾…æ˜æ—¥é‡ç½®å–”ï¼" }, errors: { firebaseInit: "Firebase åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹æª¢æŸ¥è¨­å®š", cloudConnect: "ç„¡æ³•é€£æ¥é›²ç«¯ï¼Œéƒ¨åˆ†åŠŸèƒ½å°‡å—é™", syncFavorites: "ç„¡æ³•åŒæ­¥é›²ç«¯æ”¶è—", imageLoad: "é€™å¼µåœ–ç‰‡çš„è³‡æ–™ä¼¼ä¹éºå¤±äº†", ttsFailed: "èªéŸ³åŠŸèƒ½æš«æ™‚ç„¡æ³•ä½¿ç”¨", storyFailed: "æ•…äº‹çš„éˆæ„Ÿæš«æ™‚æ¯ç«­äº†ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚" } };
const soundSettings = { masterVolume: -10, };
const styles = [ { "id": "vip-exclusive", "title": "ğŸ‘‘ VIP å°ˆå±¬", "description": "ç¨ä¸€ç„¡äºŒï¼Œåªèƒ½åœ¨å‘½é‹çš„é‚‚é€…ä¸­å¶é‡çš„ç¨€æœ‰å¥³ç¥", "prompt": "A fateful encounter with a legendary, rare goddess. Her presence is utterly unique, and a hint of curiosity in her gaze suggests she was waiting just for you." }, { "id": "beach-silhouette", "title": "ğŸ–ï¸ å¤æ—¥æˆ€æ›²", "description": "æµ·ç˜ã€æ€§æ„Ÿï¼ŒèåŒ–ä½ å¿ƒçš„å¤æ—¥æµ·ç˜æˆ€æ›²", "prompt": "å¤æ—¥è±”é™½æµ·é‚Šçš„æ²™ç˜ï¼Œä¸€ä½ç¬¦åˆæµ·é‚Šè¾£å¦¹çš„ç©¿è‘—(å¯ä»¥æ˜¯æ¯”åŸºå°¼ã€æˆ–æ˜¯æ›´å¸å¼•ç”·äººç›®å…‰çš„æµ·é‚Šæœè£)ï¼Œå°é¡é ­å±•ç¾ç†±æƒ…èˆ‡äº’å‹•ã€‚èƒŒæ™¯æ˜¯è”šè—çš„æµ·æ´‹å’Œé‡‘è‰²çš„æ²™ç˜ï¼Œé™½å…‰ç‘åœ¨å¥¹çš„èº«ä¸Šï¼Œç‡Ÿé€ å‡ºä¸€ç¨®ç†±æƒ…æ´‹æº¢ã€å……æ»¿æ´»åŠ›çš„æ°›åœã€‚", }, { "id": "morning-lazy", "title": "â˜€ï¸ æ™¨å…‰ç§æˆ¿", "description": "æ…µæ‡¶ã€ç§å¯†ã€å±¬æ–¼ä½ çš„å¥³å‹æ„Ÿç¬é–“", "prompt": "æ¸…æ™¨é™½å…‰éš™ç‘åœ¨å‡Œäº‚çš„å¤§åºŠä¸Šï¼Œä¸€ä½èº«ææ›²ç·šç²ç“ã€æ•£ç™¼æ…µæ‡¶æ°£æ¯çš„äºæ´²æ¨¡ç‰¹åœ¨åºŠä¸Šã€‚å¥¹åƒ…ç©¿è‘—ä¸€ä»¶å¯¬å¤§çš„ç”·å‹è¥¯è¡«ï¼Œé‡¦å­åŠé–‹ï¼Œçœ¼ç¥æƒºå¿ªè¿·æ¿›ï¼Œç¿»ä¾†è¦†å»å°é¡é ­æ’’å¬Œå……æ»¿ç§å¯†çš„å¥³å‹æ„Ÿèˆ‡è¦ªå¯†æ°›åœã€‚", }, { "id": "neon-noir", "title": "ğŸ’¦ æ¿•èº«é­…é­”", "description": "éœ“è™¹ã€æ…¾æœ›ã€ç„¡æ³•æŠ—æ‹’çš„å±éšªé­…åŠ›", "prompt": "åœ¨å¤§é›¨æ»‚æ²±çš„åŸå¸‚å··å¼„ä¸­ï¼Œä¸€ä½é«˜æŒ‘ã€ç‹‚é‡çš„äºæ´²æƒ¡å¥³æ¨¡ç‰¹ã€‚è¢«å¤§é›¨æ·‹æ¿•ï¼Œè¡£æœæ¿•é€ä¾ç¨€å¯è¦‹å…§æ­ï¼ŒèƒŒæ™¯æ˜¯æ¨¡ç³Šé–ƒçˆçš„éœ“è™¹ç‡ˆï¼Œå€’æ˜ åœ¨æ¿•æ»‘çš„åœ°é¢ä¸Šã€‚å¥¹çš„çœ¼ç¥å……æ»¿äº†æŒ‘é‡èˆ‡è‡ªä¿¡ï¼Œæ•£ç™¼è‘—ç„¡æ³•æŠ—æ‹’çš„å±éšªé­…åŠ›ï¼Œç•«é¢å……æ»¿ä¸å®‰èˆ‡å‹•æ„Ÿã€‚", }, { "id": "cyberpunk-warrior", "title": "ğŸ¤– è³½åšé¾å…‹æˆ°å§¬", "description": "æœªä¾†ã€ç§‘æŠ€ã€å …æ¯…çœ¼ç¥ä¸­çš„è‡´å‘½å¸å¼•åŠ›", "prompt": "(è³½åšé¾å…‹é¢¨æ ¼)åœ¨ä¸€åº§å……æ»¿é£›è¡Œè¼‰å…·èˆ‡åƒå¤©å¤§æ¨“çš„æœªä¾†åŸå¸‚ä¸­ï¼Œä¸€åèº«ç©¿ç™¼å…‰æ©Ÿæ¢°æˆ°ç”²çš„äºæ´²å¥³æˆ°å£«ï¼Œæ‰‹æŒèƒ½é‡æ­¦å™¨ï¼Œçœ¼ç¥å …æ¯…ï¼Œå‰›æ‰“ç©ä¸€å ´æˆ°å½¹æˆ–æ˜¯è·Ÿæ€ªç¸å»æ®ºå®Œã€‚å±•ç¾å‡ºè‡´å‘½çš„å¸å¼•åŠ›ï¼Œæ°£å‹¢å……æ»¿è‹±é›„æ°£æ¦‚èˆ‡å£“è¿«æ„Ÿã€‚", }];
const randomKeywords_night = { /* ... Omitted for brevity ... */ };
const randomKeywords_day = { /* ... Omitted for brevity ... */ };

// --- Start of stateManager.js ---
let _state = {};
const _subscribers = {};
function initState(initialState) { _state = initialState; console.log("State Manager initialized with:", _state); }
function getState(...keys) { if (keys.length === 1) { return _state[keys[0]]; } const requestedState = {}; for (const key of keys) { if (key in _state) { requestedState[key] = _state[key]; } else { console.warn(`[State Manager] Attempted to get non-existent state key: "${key}"`); } } return requestedState; }
function setState(newState) { for (const key in newState) { if (Object.prototype.hasOwnProperty.call(newState, key)) { if (_state[key] !== newState[key]) { _state[key] = newState[key]; if (_subscribers[key]) { _subscribers[key].forEach(callback => { try { callback(_state[key]); } catch (e) { console.error(`[State Manager] Error in subscriber for key "${key}":`, e); } }); } } } } }
function subscribe(key, callback) { if (!_subscribers[key]) { _subscribers[key] = []; } _subscribers[key].push(callback); if (key in _state) { try { callback(_state[key]); } catch (e) { console.error(`[State Manager] Error in initial callback for key "${key}":`, e); } } return () => { _subscribers[key] = _subscribers[key].filter(cb => cb !== callback); }; }

// --- Start of state.js ---
function getInitialState() { const storedApiKey = localStorage.getItem('userGeminiApiKey'); const hasUserApiKey = !!storedApiKey; const storedImageQuality = localStorage.getItem('userImageQuality'); const storedNickname = localStorage.getItem('userNickname'); return { isGenerating: false, activeStyleId: styles[0].id, isStoryGenerating: false, isTtsGenerating: false, favorites: null, ownGoddessStreak: 0, touchStartX: 0, touchEndX: 0, currentSlideshowIndex: 0, currentTheme: 'night', userApiKey: storedApiKey || serviceKeys.defaultApiKey, hasUserApiKey: hasUserApiKey, imageQuality: storedImageQuality || 'thumbnail', isAppInitialized: false, userNickname: storedNickname || '', }; }

// --- Start of soundManager.js ---
const dummySound = () => {};
const sounds = { start: dummySound, success: dummySound, tab: dummySound, open: dummySound, like: dummySound, gacha: dummySound, toDay: dummySound, toNight: dummySound, };
let isSoundInitialized = false;
async function initSounds() { if (isSoundInitialized) return; try { await Tone.start(); const mainSynth = new Tone.Synth().toDestination(); const fmSynth = new Tone.FMSynth().toDestination(); const tabSynth = new Tone.Synth().toDestination(); sounds.start = () => fmSynth.triggerAttackRelease("C2", "8n"); sounds.success = () => { mainSynth.triggerAttackRelease("C5", "16n", Tone.now()); mainSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.1); }; sounds.tab = () => tabSynth.triggerAttackRelease("C4", "32n"); sounds.open = () => fmSynth.triggerAttackRelease("A3", "16n"); sounds.like = () => mainSynth.triggerAttackRelease("A5", "32n"); sounds.gacha = () => { const synth = new Tone.PolySynth(Tone.Synth).toDestination(); const now = Tone.now(); synth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now); synth.triggerAttackRelease(["F4", "A4", "C5", "E5"], "8n", now + 0.2); synth.triggerAttackRelease(["G4", "B4", "D5", "G5"], "4n", now + 0.4); }; sounds.toDay = () => new Tone.AMSynth().toDestination().triggerAttackRelease("C4", "2n"); sounds.toNight = () => new Tone.FMSynth().toDestination().triggerAttackRelease("G5", "8n"); Tone.Master.volume.value = soundSettings.masterVolume; isSoundInitialized = true; console.log("éŸ³æ•ˆå¼•æ“å·²æˆåŠŸåˆå§‹åŒ–ã€‚"); } catch (e) { console.error("ç„¡æ³•å•Ÿå‹•éŸ³æ•ˆå¼•æ“:", e); } }

// --- Start of dailyTaskManager.js ---
class DailyTask {
    constructor(taskName, db, userId) { this.name = taskName; this.db = db; this.userId = userId; this.defaultCount = gameSettings.dailyLimits[taskName]; this.state = { count: this.defaultCount, lastUpdate: null, }; this.docRef = doc(this.db, dbCollectionNames.users, userId, dbCollectionNames.dailyTasks, this.name); this.isInitialized = false; }
    // âœ¨ FIX: Replaced private field '#' with '_' for compatibility
    async _checkAndSync() { if (this.isInitialized && this.state.lastUpdate === new Date().toISOString().split('T')[0]) { return; } const today = new Date().toISOString().split('T')[0]; const docSnap = await getDoc(this.docRef); if (docSnap.exists()) { const dbState = docSnap.data(); if (dbState.lastUpdate === today) { this.state = dbState; } else { const newCount = Math.max(dbState.count, this.defaultCount); this.state.count = newCount; this.state.lastUpdate = today; await this._save(); } } else { this.state.count = this.defaultCount; this.state.lastUpdate = today; await this._save(); } this.isInitialized = true; }
    async _save() { await setDoc(this.docRef, this.state); }
    async getCount() { await this._checkAndSync(); return this.state.count; }
    async use() { await this._checkAndSync(); if (this.state.count > 0) { this.state.count--; await this._save(); return true; } return false; }
    async add(amount) { await this._checkAndSync(); this.state.count += amount; await this._save(); return this.state.count; }
}
async function migrateOldData(db, userId) { /* ... Omitted for brevity ... */ }
const tasks = {};
async function initDailyTaskManager(firestoreInstance, uid) { if (!firestoreInstance || !uid) { console.error("DailyTaskManager init failed."); return; } const checkRef = doc(firestoreInstance, dbCollectionNames.users, uid, dbCollectionNames.dailyTasks, 'gacha'); const checkSnap = await getDoc(checkRef); if (!checkSnap.exists()) { await migrateOldData(firestoreInstance, uid); } for (const taskName in gameSettings.dailyLimits) { tasks[taskName] = new DailyTask(taskName, firestoreInstance, uid); } }
async function getTaskCount(taskName) { if (!tasks[taskName]) throw new Error(`Task "${taskName}" undefined.`); return tasks[taskName].getCount(); }
async function useTask(taskName) { if (!tasks[taskName]) throw new Error(`Task "${taskName}" undefined.`); return tasks[taskName].use(); }
async function addTaskCount(taskName, amount) { if (!tasks[taskName]) throw new Error(`Task "${taskName}" undefined.`); return tasks[taskName].add(amount); }

// --- Start of analyticsManager.js ---
let analyticsDb, analyticsUserId, statsRef;
async function initAnalyticsManager(firestoreInstance, uid) { analyticsDb = firestoreInstance; analyticsUserId = uid; statsRef = doc(analyticsDb, 'users', analyticsUserId, 'statistics', 'userStats'); const docSnap = await getDoc(statsRef); if (!docSnap.exists()) { const nickname = randomNicknames[Math.floor(Math.random() * randomNicknames.length)]; const userDocRef = doc(analyticsDb, 'users', analyticsUserId); await Promise.all([ setDoc(statsRef, { ...userStatsStructure, firstLogin: serverTimestamp(), lastLogin: serverTimestamp() }), setDoc(userDocRef, { nickname: nickname }) ]); console.log(`Initialized stats for new user ${analyticsUserId} with nickname: ${nickname}`); } else { await setDoc(statsRef, { lastLogin: serverTimestamp() }, { merge: true }); } }
async function incrementStat(fieldsToIncrement) { if (!statsRef) { console.warn("Analytics Manager not initialized."); return; } try { const updatePayload = {}; for (const key in fieldsToIncrement) { if (Object.hasOwnProperty.call(fieldsToIncrement, key)) { updatePayload[key] = increment(fieldsToIncrement[key]); } } await setDoc(statsRef, updatePayload, { merge: true }); } catch (error) { console.error("Error updating stats:", error); } }

// --- Start of gfirebase.js ---
let db, auth, storage, currentUserId;
function initFirebase() { try { const app = initializeApp(serviceKeys.firebaseConfig); auth = getAuth(app); db = getFirestore(app); storage = getStorage(app); console.log("Firebase initialized successfully."); return true; } catch (error) { console.error("Firebase initialization failed:", error); return false; } }
function handleAuthentication(onUserSignedIn) { onAuthStateChanged(auth, (user) => { if (user) { currentUserId = user.uid; if (onUserSignedIn) onUserSignedIn(currentUserId); } else { signInAnonymously(auth).catch((error) => { if (onUserSignedIn) onUserSignedIn(null, error); }); } }); }
function getCurrentUserId() { return currentUserId; }
async function getUserData(db, uid) { if (!uid) return null; const userRef = doc(db, dbCollectionNames.users, uid); const docSnap = await getDoc(userRef); if (docSnap.exists()) { return docSnap.data(); } else { return { nickname: 'ç„¡åæ°' }; } }
async function saveNickname(uid, nickname) { if (!uid) throw new Error("User not signed in."); const userRef = doc(db, dbCollectionNames.users, uid); await setDoc(userRef, { nickname: nickname }, { merge: true }); }
function getResizedImageUrl(originalUrl) { /* ... Omitted for brevity ... */ return originalUrl; }
function listenToFavorites(callback) { if (!currentUserId) return () => {}; const favoritesCol = collection(db, dbCollectionNames.users, currentUserId, dbCollectionNames.favorites); const unsubscribe = onSnapshot(favoritesCol, (snapshot) => { const newFavorites = snapshot.docs.map(doc => { const data = doc.data(); return { ...data, resizedUrl: getResizedImageUrl(data.imageUrl) }; }); callback(newFavorites); }, (error) => { console.error("Error listening to favorites:", error); callback([], error); }); return unsubscribe; }
async function saveFavorite(favoriteData) { if (!currentUserId) throw new Error("User not signed in."); const favoriteRef = doc(db, dbCollectionNames.users, currentUserId, dbCollectionNames.favorites, favoriteData.id); await setDoc(favoriteRef, { id: favoriteData.id, style: favoriteData.style, imageUrl: favoriteData.imageUrl }); }
async function removeFavorite(favoriteToRemove) { if (!currentUserId) throw new Error("User not signed in."); const favoriteRef = doc(db, dbCollectionNames.users, currentUserId, dbCollectionNames.favorites, favoriteToRemove.id); await deleteDoc(favoriteRef); }
async function uploadImage(base64String, imageId) { if (!currentUserId) throw new Error("User not signed in."); const storageRef = ref(storage, `${dbCollectionNames.users}/${currentUserId}/images/${imageId}.png`); const snapshot = await uploadString(storageRef, base64String, 'data_url'); return await getDownloadURL(snapshot.ref); }
async function shareToPublic(publicData) { if (!currentUserId) throw new Error("User not signed in."); const publicRef = doc(db, dbCollectionNames.publicGoddesses, publicData.id); const docSnap = await getDoc(publicRef); if (docSnap.exists()) { return { alreadyExists: true }; } await setDoc(publicRef, { id: publicData.id, style: publicData.style, imageUrl: publicData.imageUrl, sharedBy: currentUserId }); return { alreadyExists: false }; }
async function updatePublicGoddessVote(goddessId, voterId, action) { /* ... Omitted for brevity ... */ }
async function addDislikeToGoddess(goddessId, dislikerId) { /* ... Omitted for brevity ... */ }
async function getRandomGoddessFromDB() { const q = query(collection(db, dbCollectionNames.publicGoddesses), limit(gameSettings.gachaQueryLimit)); const snapshot = await getDocs(q); if (snapshot.empty) { throw new Error("çæ± æ˜¯ç©ºçš„ï¼"); } const allDocs = snapshot.docs; const randomIndex = Math.floor(Math.random() * allDocs.length); const data = allDocs[randomIndex].data(); return { ...data, resizedUrl: getResizedImageUrl(data.imageUrl) }; }
async function getRandomGoddessesFromDB(count) { const q = query(collection(db, dbCollectionNames.publicGoddesses), limit(gameSettings.gachaQueryLimit)); const snapshot = await getDocs(q); if (snapshot.empty) { return []; } const allDocs = snapshot.docs.map(doc => { const data = doc.data(); return { ...data, resizedUrl: getResizedImageUrl(data.imageUrl) }; }); const shuffled = allDocs.sort(() => 0.5 - Math.random()); return shuffled.slice(0, count); }

// --- Start of api.js ---
function getRandomItems(arr, count) { const shuffled = [...arr].sort(() => 0.5 - Math.random()); return shuffled.slice(0, count); }
async function generateImageWithRetry(prompt) { /* ... Omitted for brevity ... */ }
async function callImageGenerationAPI(userPrompt, model) { const userApiKey = getState('userApiKey'); const modelName = model === 'imagen-3' ? 'imagen-3.0-generate-002' : 'gemini-2.0-flash-preview-image-generation'; const isImagen = model === 'imagen-3'; const apiUrl = isImagen ? `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:predict?key=${userApiKey}` : `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${userApiKey}`; const payload = isImagen ? { instances: [{ prompt: userPrompt }], parameters: { "sampleCount": 1 } } : { contents: [{ parts: [{ text: userPrompt }] }], generationConfig: { responseModalities: ['TEXT', 'IMAGE'] }, }; const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!response.ok) { const errorData = await response.json(); const errorMessage = errorData && errorData.error ? errorData.error.message : response.statusText; throw new Error(`API è«‹æ±‚å¤±æ•—: ${errorMessage}`); } const result = await response.json(); if (isImagen) { const base64Data = result && result.predictions && result.predictions.length > 0 ? result.predictions[0].bytesBase64Encoded : null; if (!base64Data) { throw new Error("Imagen API å›æ‡‰ä¸­æ‰¾ä¸åˆ°åœ–ç‰‡è³‡æ–™ã€‚"); } return `data:image/png;base64,${base64Data}`; } const candidate = result && result.candidates && result.candidates.length > 0 ? result.candidates[0] : null; if (!candidate) { throw new Error("API å›æ‡‰ç„¡æ•ˆï¼Œæ‰¾ä¸åˆ°å€™é¸é …ç›®ã€‚"); } if (candidate.finishReason && candidate.finishReason !== 'STOP') { throw new Error(`åœ–ç‰‡ç”Ÿæˆå› å®‰å…¨é™åˆ¶è¢«é˜»æ“‹ï¼Œè«‹å˜—è©¦æ›´æ›æç¤ºè©ã€‚`); } const imagePart = candidate && candidate.content && candidate.content.parts ? candidate.content.parts.find(p => p.inlineData) : null; const base64Data = imagePart && imagePart.inlineData ? imagePart.inlineData.data : null; if (!base64Data) { throw new Error("API å›æ‡‰ä¸­æ‰¾ä¸åˆ°åœ–ç‰‡è³‡æ–™ã€‚"); } return `data:image/png;base64,${base64Data}`; }
async function callTextGenerationAPI(prompt) { /* ... Omitted for brevity ... */ }
async function callTTSAPI(text) { /* ... Omitted for brevity ... */ }

// --- Start of gui.js ---
const favoritesCountEl = document.getElementById('favorites-count');
const messageBox = document.getElementById('message-box');
function showMessage(text, isError = false) { messageBox.textContent = text; messageBox.style.backgroundColor = isError ? '#E11D48' : '#EC4899'; messageBox.classList.add('show'); setTimeout(() => messageBox.classList.remove('show'), 3000); }
function updateFavoritesCountUI(count) { if (favoritesCountEl) { favoritesCountEl.textContent = count; } }
function createImageCard(imageData, handlers, options = {}) { const { withAnimation = true, withButtons = true } = options; const { style, id, isLiked, isShared, isShareable = true, isGachaCard = false, likeCount = 0, dislikeCount = 0, userHasDisliked = false } = imageData; const displaySrc = imageData.resizedUrl || imageData.imageUrl || imageData.src; const originalSrc = imageData.imageUrl || imageData.src; const imageCard = document.createElement('div'); imageCard.className = 'image-card'; imageCard.dataset.id = id; imageCard.dataset.originalSrc = originalSrc; const dislikeButtonText = userHasDisliked ? 'å·²è©•åƒ¹ âœ…' : 'æˆ‘è¦ºå¾—ä¸è¡Œ!...ğŸ‘'; const dislikeButtonDisabled = userHasDisliked ? 'disabled' : ''; let statsTagsHTML = ''; if (isGachaCard && (likeCount > 0 || dislikeCount > 0)) { statsTagsHTML = `<div class="stats-tags-container">${likeCount > 0 ? `<span class="stat-tag like-tag">â¤ï¸ ${likeCount}</span>` : ''}${dislikeCount > 0 ? `<span class="stat-tag dislike-tag">ğŸ‘ ${dislikeCount}</span>` : ''}</div>`; } const mainButtonHTML = isGachaCard ? `<button class="dislike-btn story-btn" ${dislikeButtonDisabled}>${dislikeButtonText}</button>` : `<button class="story-btn">ç”Ÿæˆæ•…äº‹ âœ¨</button>`; const footerHTML = withButtons ? `<div class="card-footer">${mainButtonHTML}<div class="card-actions">${isShareable && !isGachaCard ? `<button class="share-btn ${isShared ? 'shared' : ''}" title="åˆ†äº«è‡³å…¬é–‹æ®¿å ‚">ğŸŒ</button>` : ''}<button class="like-btn ${isLiked ? 'liked' : ''}" title="æ”¶è—è‡³ç§äººæ®¿å ‚">â™¥</button></div></div>` : ''; const imageWrapperContent = `<img alt="${style ? style.title : 'Gacha Image'}" loading="lazy">${statsTagsHTML}`; if (withAnimation) { imageCard.innerHTML = `<div class="flipper"><div class="card-face card-front"><div class="loader"></div></div><div class="card-face card-back"><div class="image-card-img-wrapper">${imageWrapperContent}</div>${footerHTML}</div></div>`; } else { imageCard.style.opacity = '1'; imageCard.style.animation = 'none'; imageCard.style.position = 'relative'; imageCard.innerHTML = `<div class="image-card-img-wrapper" style="width: 100%; height: 100%;"><img alt="${style ? style.title : 'Gacha Image'}" loading="lazy" style="width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.5s;">${statsTagsHTML}</div>${footerHTML}`; } const img = imageCard.querySelector('img'); img.onload = () => { if (withAnimation) { const flipper = imageCard.querySelector('.flipper'); setTimeout(() => { flipper.classList.add('reveal'); }, 50); } else { img.style.opacity = '1'; } }; img.onerror = function() { /* ... Omitted for brevity ... */ }; if (withButtons) { imageCard.addEventListener('click', (e) => { const clickedCard = e.currentTarget; if (e.target.closest('.story-btn') && !e.target.closest('.dislike-btn')) { e.stopPropagation(); if (id === 'vip-placeholder') { showMessage('æ­¤ç‚ºé è¦½å¡ç‰‡ï¼Œç„¡æ³•ç”Ÿæˆæ•…äº‹å–”ï¼'); return; } handlers.onStory(style); } else if (e.target.closest('.dislike-btn')) { e.stopPropagation(); handlers.onDislike(imageData, e.target.closest('.dislike-btn')); } else if (e.target.closest('.like-btn')) { e.stopPropagation(); handlers.onLike(imageData, e.target.closest('.like-btn')); } else if (e.target.closest('.share-btn')) { e.stopPropagation(); handlers.onShare(imageData, e.target.closest('.share-btn')); } else if (e.target.closest('.image-card-img-wrapper')) { handlers.onImageClick(clickedCard); } }); } else { imageCard.addEventListener('click', (e) => { const clickedCard = e.currentTarget; if (e.target.closest('.image-card-img-wrapper')) { handlers.onImageClick(clickedCard); } }); } img.src = displaySrc; return imageCard; }
let particlesArray;
class Particle { constructor(x, y, dX, dY, s, c) { this.x=x;this.y=y;this.directionX=dX;this.directionY=dY;this.size=s;this.color=c; } draw() { const ctx = document.getElementById('background-canvas').getContext('2d'); ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false); ctx.fillStyle = this.color; ctx.fill(); } update() { const canvas = document.getElementById('background-canvas'); if(this.x > canvas.width || this.x < 0) this.directionX = -this.directionX; if(this.y > canvas.height || this.y < 0) this.directionY = -this.directionY; this.x += this.directionX; this.y += this.directionY; this.draw(); } }
function initParticles() { const canvas = document.getElementById('background-canvas'); if (!canvas) return; canvas.width = innerWidth; canvas.height = innerHeight; particlesArray = []; let num = (canvas.height * canvas.width) / 9000; for (let i = 0; i < num; i++) { let size = (Math.random() * 2) + 1; let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2); let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2); let dX = (Math.random() * .4) - .2; let dY = (Math.random() * .4) - .2; particlesArray.push(new Particle(x, y, dX, dY, size, 'rgba(139, 92, 246, 0.3)')); } }
function animateParticles() { const canvas = document.getElementById('background-canvas'); if (!canvas) return; const ctx = canvas.getContext('2d'); requestAnimationFrame(animateParticles); ctx.clearRect(0, 0, innerWidth, innerHeight); if(particlesArray) { for (let i = 0; i < particlesArray.length; i++) { particlesArray[i].update(); } } }
window.addEventListener('resize', () => { initParticles(); });
class Petal { constructor(c) { this.canvas = c; this.x = Math.random()*c.width; this.y = Math.random()*c.height*2-c.height; this.w = 20+Math.random()*15; this.h = 15+Math.random()*10; this.opacity = this.w/35; this.xSpeed = 1+Math.random(); this.ySpeed = .5+Math.random()*.5; this.flip = Math.random(); this.flipSpeed = Math.random()*.03; } draw() { const ctx = this.canvas.getContext('2d'); if(this.y > this.canvas.height || this.x > this.canvas.width){this.x=-this.w; this.y=Math.random()*this.canvas.height*2-this.canvas.height;} ctx.globalAlpha = this.opacity; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.bezierCurveTo(this.x+this.w/2, this.y-this.h/2, this.x+this.w, this.y, this.x+this.w/2, this.y+this.h/2); ctx.closePath(); const grad = ctx.createLinearGradient(this.x, this.y, this.x+this.w, this.y+this.h); grad.addColorStop(0, 'rgba(255,192,203,.8)'); grad.addColorStop(1, 'rgba(236,72,153,.5)'); ctx.fillStyle = grad; ctx.fill(); } animate() { this.x+=this.xSpeed; this.y+=this.ySpeed; this.flip+=this.flipSpeed; this.draw(); } }
function resizeLoadingCanvas(c) { if (!c) return; c.width=window.innerWidth; c.height=window.innerHeight; }
function animateLoading(c, p, o) { if (!c || !o || o.classList.contains('hidden')) return; const ctx = c.getContext('2d'); ctx.clearRect(0,0,c.width,c.height); p.forEach(petal => petal.animate()); requestAnimationFrame(() => animateLoading(c, p, o)); }

// --- Start of handlers.js ---
function generateUniqueId() { return Date.now().toString(36) + Math.random().toString(36).substring(2); }
function base64ToArrayBuffer(base64) { const binaryString = window.atob(base64); const len = binaryString.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); } return bytes.buffer; }
function pcmToWav(pcmData, sampleRate) { /* ... Omitted for brevity ... */ return new Blob([], {type: 'audio/wav'}); }
async function handleImageGeneration(count = 1) { /* ... Omitted for brevity ... */ }
async function handleDislike(imageData, btn) { /* ... Omitted for brevity ... */ }
function getCardHandlers() { return { onStory: handleStoryGeneration, onLike: (imageData, btn) => toggleFavorite(imageData, btn), onShare: shareFavoriteToPublicHandler, onImageClick: (cardElement) => { const originalSrc = cardElement.dataset.originalSrc; const modalImage = document.getElementById('modal-image'); const imageModal = document.getElementById('image-modal'); modalImage.src = originalSrc; imageModal.classList.add('show'); }, onDislike: handleDislike }; }
async function handleStoryGeneration(style) { /* ... Omitted for brevity ... */ }
async function handleTTSGeneration(text) { /* ... Omitted for brevity ... */ }
async function toggleFavorite(imageData, btn) { if (imageData.id === 'vip-placeholder') { showMessage('æ­¤ç‚ºé è¦½å¡ç‰‡ï¼Œç„¡æ³•æ”¶è—å–”ï¼'); return; } const favorites = getState('favorites'); const currentUserIdValue = getCurrentUserId(); if (favorites === null || !currentUserIdValue) { showMessage("é›²ç«¯è³‡æ–™åŒæ­¥ä¸­æˆ–å°šæœªç™»å…¥ï¼Œè«‹ç¨å€™å†è©¦...", true); return; } sounds.like(); if (btn) btn.disabled = true; const index = favorites.findIndex(fav => fav && fav.id === imageData.id); if (index > -1) { incrementStat({ unlikes: 1 }); try { await removeFavorite(favorites[index]); await updatePublicGoddessVote(imageData.id, currentUserIdValue, 'unlike'); } catch (error) { console.error("Failed to remove favorite:", error); showMessage(uiMessages.favorites.removeFailure, true); } } else { incrementStat({ likes: 1 }); try { let favoriteData; if (imageData.src && imageData.src.startsWith('data:image')) { showMessage(uiMessages.favorites.uploading); const downloadURL = await uploadImage(imageData.src, imageData.id); favoriteData = { id: imageData.id, style: imageData.style, imageUrl: downloadURL }; } else { favoriteData = { id: imageData.id, style: imageData.style, imageUrl: imageData.imageUrl }; } await saveFavorite(favoriteData); await updatePublicGoddessVote(imageData.id, currentUserIdValue, 'like'); showMessage(uiMessages.favorites.addSuccess); const cardExists = document.querySelector(`.image-card[data-id="${imageData.id}"]`); if (!cardExists && imageData.style && imageData.style.id) { const gallery = document.getElementById(`${imageData.style.id}-gallery`); if (gallery) { const newCardData = { ...imageData, isLiked: true }; const newCard = createImageCard(newCardData, getCardHandlers()); gallery.appendChild(newCard); } } } catch (error) { console.error("Failed to save favorite:", error); showMessage(`${uiMessages.favorites.addFailure}: ${error.message}`, true); } } if (btn) btn.disabled = false; }
async function shareFavoriteToPublicHandler(imageData, btn) { /* ... Omitted for brevity ... */ }
async function unfavoriteCurrentSlide() { /* ... Omitted for brevity ... */ }
async function drawGacha() { /* ... Omitted for brevity ... */ }

// --- Start of uiManager.js ---
let DOMElements = {};
let currentAnnouncementPage = 0;
function initializeUI() { DOMElements = { headerTitle: document.getElementById('header-title'), storyModalTitle: document.getElementById('story-modal-title'), gachaModalTitle: document.getElementById('gacha-modal-title'), tabNavigation: document.getElementById('tab-navigation'), styleSectionsContainer: document.getElementById('style-sections'), generateOneBtn: document.getElementById('generate-one-btn'), generateFourBtn: document.getElementById('generate-four-btn'), gachaBtn: document.getElementById('gacha-btn'), gachaDrawBtn: document.getElementById('gacha-draw-btn'), gachaUnlockInfo: document.getElementById('gacha-unlock-info'), ttsBtn: document.getElementById('tts-btn'), ttsStopBtn: document.getElementById('tts-stop-btn'), ttsLimitInfo: document.getElementById('tts-limit-info'), ttsAudio: document.getElementById('tts-audio'), favoritesBtn: document.getElementById('favorites-btn'), favoritesBtnText: document.getElementById('favorites-btn-text'), slideshowModal: document.getElementById('slideshow-modal'), slideshowImage: document.getElementById('slideshow-image'), thumbnailBar: document.getElementById('thumbnail-bar'), slideshowContainer: document.getElementById('slideshow-container'), favoritesEmptyState: document.getElementById('favorites-empty-state'), themeSwitchBtn: document.getElementById('theme-switch-btn'), sunIcon: document.getElementById('sun-icon'), moonIcon: document.getElementById('moon-icon'), soundControl: document.getElementById('sound-control'), soundOnIcon: document.getElementById('sound-on-icon'), soundOffIcon: document.getElementById('sound-off-icon'), moreOptionsBtn: document.getElementById('more-options-btn'), moreOptionsMenu: document.getElementById('more-options-menu'), settingsBtn: document.getElementById('settings-btn'), aboutBtn: document.getElementById('about-btn'), contactBtn: document.getElementById('contact-btn'), apikeyBtn: document.getElementById('apikey-btn'), gachaModal: document.getElementById('gacha-modal'), gachaCloseBtn: document.getElementById('gacha-close-btn'), storyModal: document.getElementById('story-modal'), imageModal: document.getElementById('image-modal'), apikeyModal: document.getElementById('apikey-modal'), apikeyModalContent: document.getElementById('apikey-modal-content'), contactModal: document.getElementById('contact-modal'), contactModalContent: document.getElementById('contact-modal-content'), comingSoonModal: document.getElementById('coming-soon-modal'), comingSoonModalContent: document.getElementById('coming-soon-modal-content'), settingsModal: document.getElementById('settings-modal'), settingsModalContent: document.getElementById('settings-modal-content'), announcementModal: document.getElementById('announcement-modal'), announcementModalContent: document.getElementById('announcement-modal-content'), userInfo: document.getElementById('user-info'), rankingBtn: document.getElementById('ranking-btn'), announcementOpenBtn: document.getElementById('announcement-open-btn'), }; setupUIText(); createTabsAndSections(); addEventListeners(); setupSubscriptions(); }
function setupUIText() { /* ... Omitted for brevity ... */ }
function createTabsAndSections() { styles.forEach((style, index) => { const tabButton = document.createElement('button'); tabButton.className = `tab-button text-md font-medium py-2 px-4 text-gray-400 ${index === 0 ? 'active' : ''}`; tabButton.textContent = style.title; tabButton.dataset.target = `content-${style.id}`; tabButton.dataset.styleId = style.id; DOMElements.tabNavigation.appendChild(tabButton); const section = document.createElement('section'); section.id = `content-${style.id}`; section.className = `tab-content ${index === 0 ? 'active' : ''}`; section.innerHTML = `<div class="text-center mb-8 mt-4"><p class="text-gray-400 mt-1">${style.description}</p></div><div id="${style.id}-gallery" class="card-container mb-8"></div>`; DOMElements.styleSectionsContainer.appendChild(section); }); }
function addEventListeners() { /* ... Omitted for brevity ... */ }
function setupSubscriptions() { subscribe('activeStyleId', (styleId) => { document.querySelectorAll('.tab-button').forEach(btn => btn.classList.toggle('active', btn.dataset.styleId === styleId)); document.querySelectorAll('.tab-content').forEach(content => content.classList.toggle('active', content.id === `content-${styleId}`)); updateGenerateButtonsState(); }); subscribe('isGenerating', (isGenerating) => { updateGenerateButtonsState(); }); subscribe('hasUserApiKey', () => { updateAllTaskUIs(); }); subscribe('isStoryGenerating', (isGenerating) => { updateTtsUi(); }); subscribe('isTtsGenerating', (isGenerating) => { DOMElements.ttsBtn.style.display = isGenerating ? 'none' : 'inline-block'; DOMElements.ttsStopBtn.style.display = isGenerating ? 'inline-block' : 'none'; if (!isGenerating) { updateTtsUi(); } else { DOMElements.ttsBtn.textContent = 'è²éŸ³åˆæˆä¸­...'; DOMElements.ttsBtn.disabled = true; } }); }
async function updateAllTaskUIs() { if (!getState('isAppInitialized')) { return; } await updateGenerateButtonsState(); await updateGachaUI(); await updateTtsUi(); }
async function updateGenerateButtonsState() { /* ... Omitted for brevity ... */ }
async function updateGachaUI() { /* ... Omitted for brevity ... */ }
async function updateTtsUi() { /* ... Omitted for brevity ... */ }
function openGachaModal() { /* ... Omitted for brevity ... */ }
function openApiKeyModal() { /* ... Omitted for brevity ... */ }
function openContactModal() { /* ... Omitted for brevity ... */ }
async function handleContactFormSubmit(e) { /* ... Omitted for brevity ... */ }
function toggleMute() { /* ... Omitted for brevity ... */ }
function toggleTheme() { /* ... Omitted for brevity ... */ }
function openSlideshow() { /* ... Omitted for brevity ... */ }
function updateSlideshowUI(favorites) { /* ... Omitted for brevity ... */ }
function navigateSlideshow(direction) { /* ... Omitted for brevity ... */ }
function showSlide(index) { /* ... Omitted for brevity ... */ }
function renderThumbnails() { /* ... Omitted for brevity ... */ }
function openSettingsModal() { /* ... Omitted for brevity ... */ }
function updateUserInfo(uid, nickname, isConnecting = false) { if (DOMElements.userInfo) { if (isConnecting) { DOMElements.userInfo.innerHTML = `é›²ç«¯é€£ç·šä¸­...`; } else if (uid) { const nicknameHTML = nickname ? `<span class="user-nickname">(${nickname})</span>` : ''; DOMElements.userInfo.innerHTML = `é›²ç«¯ä½¿ç”¨è€… ${nicknameHTML} ID: ${uid}`; } else { DOMElements.userInfo.innerHTML = `é›²ç«¯ä½¿ç”¨è€… ID: å°šæœªç™»å…¥`; } } }
function renderAnnouncementPage(pageIndex) { /* ... Omitted for brevity ... */ }
function openAnnouncementModal(forceShow = false) { if (!announcementSettings.enabled || !announcementSettings.pages || announcementSettings.pages.length === 0) return; if (!forceShow && announcementSettings.checkLocalStorage) { const lastShownDate = localStorage.getItem('announcementLastShown'); const today = new Date().toISOString().split('T')[0]; if (lastShownDate === today) { return; } } currentAnnouncementPage = 0; renderAnnouncementPage(currentAnnouncementPage); DOMElements.announcementModal.classList.add('show'); }

// --- Start of gmain.js (Main Logic) ---
let isLoadingOverlayHidden = false;
function hideLoadingOverlay() { if (isLoadingOverlayHidden) return; const loadingOverlay = document.getElementById('loading-overlay'); if (loadingOverlay) { loadingOverlay.classList.add('hidden'); } if (!getCurrentUserId()) { updateAllTaskUIs(); } openAnnouncementModal(); isLoadingOverlayHidden = true; }
window.onload = () => { initState(getInitialState()); setupAppInfo(); window.firebaseConfig = serviceKeys.firebaseConfig; initializeUI(); setupStateSubscriptions(); updateUserInfo(null, null, true); if (!uiSettings.enableLoadingAnimation) { hideLoadingOverlay(); if (initFirebase()) { handleAuthentication(onUserSignedIn); } else { showMessage(uiMessages.errors.firebaseInit, true); } } else { startLoadingSequence(); if (initFirebase()) { handleAuthentication(onUserSignedIn); } else { showMessage(uiMessages.errors.firebaseInit, true); hideLoadingOverlay(); } } initParticles(); animateParticles(); const startAudioOnce = async () => { await initSounds(); document.body.removeEventListener('click', startAudioOnce); document.body.removeEventListener('touchend', startAudioOnce); }; document.body.addEventListener('click', startAudioOnce); document.body.addEventListener('touchend', startAudioOnce); };
async function onUserSignedIn(uid, error) { if (uid) { const db = getFirestore(initializeApp(serviceKeys.firebaseConfig)); const [_, __, userData] = await Promise.all([ initDailyTaskManager(db, uid), initAnalyticsManager(db, uid), getUserData(db, uid) ]); const nickname = (userData && userData.nickname) ? userData.nickname : ''; updateUserInfo(uid, nickname); setState({ userNickname: nickname }); if (nickname) { localStorage.setItem('userNickname', nickname); } listenToFavorites(onFavoritesUpdate); setState({ isAppInitialized: true }); updateAllTaskUIs(); if (uiSettings.hideLoadingOnConnect) { hideLoadingOverlay(); } } else { showMessage(uiMessages.errors.cloudConnect, true); console.error("Authentication Error:", error); setState({ isAppInitialized: true }); updateUserInfo(null, null, false); if (uiSettings.hideLoadingOnConnect) { hideLoadingOverlay(); } } }
function onFavoritesUpdate(newFavorites, err) { if (err) { showMessage(uiMessages.errors.syncFavorites, true); setState({ favorites: [] }); return; } setState({ favorites: newFavorites }); }
function startLoadingSequence() { const loadingOverlay = document.getElementById('loading-overlay'); const loadingText = document.getElementById('loading-text'); const silhouetteContainer = document.querySelector('.silhouette-container'); const loadingCanvas = document.getElementById('loading-canvas'); if (loadingText) loadingText.textContent = uiMessages.loading.connecting; const silhouettes = [...uiSettings.loadingSilhouettes].sort(() => 0.5 - Math.random()); silhouetteContainer.innerHTML = silhouettes.map(src => `<img src="${src}" class="loading-silhouette" alt="Loading Muse">`).join(''); const silhouetteElements = document.querySelectorAll('.loading-silhouette'); if (silhouetteElements.length > 0) { const animationStep = uiSettings.loadingAnimationStep; const totalDuration = silhouetteElements.length * animationStep; silhouetteElements.forEach((el, index) => { el.style.animationDelay = `${index * animationStep}s`; el.style.animationDuration = `${totalDuration}s`; el.style.animationName = 'silhouette-fade'; }); } resizeLoadingCanvas(loadingCanvas); let petals = Array.from({ length: uiSettings.loadingPetalCount }, () => new Petal(loadingCanvas)); animateLoading(loadingCanvas, petals, loadingOverlay); setTimeout(() => { if (loadingText) loadingText.textContent = uiMessages.loading.starting; setTimeout(() => { hideLoadingOverlay(); if (!getCurrentUserId()) { updateAllTaskUIs(); } openAnnouncementModal(); }, 500); }, uiSettings.loadingScreenDuration); }
async function generateInitialImages(favorites) { for (const fav of favorites) { const displayUrl = fav.resizedUrl || fav.imageUrl; if (!fav || !fav.style || !fav.style.id || !displayUrl) continue; const gallery = document.getElementById(`${fav.style.id}-gallery`); if (gallery) { const imageData = { ...fav, src: displayUrl, isLiked: true }; const imageCard = createImageCard(imageData, getCardHandlers()); gallery.appendChild(imageCard); } } if (favorites.length < 4) { try { const randomGoddesses = await getRandomGoddessesFromDB(4); for (const goddess of randomGoddesses) { if (document.querySelector(`.image-card[data-id="${goddess.id}"]`)) continue; const displayUrl = goddess.resizedUrl || goddess.imageUrl; const gallery = document.getElementById(`${goddess.style.id}-gallery`); if (gallery) { const imageData = { ...goddess, src: displayUrl, isLiked: favorites.some(fav => fav.id === goddess.id) }; const imageCard = createImageCard(imageData, getCardHandlers()); gallery.appendChild(imageCard); } } } catch (error) { console.error("Failed to fetch initial random goddesses:", error); showMessage(error.message, true); } } }
function setupAppInfo() { const headerTitleEl = document.getElementById('header-title'); const appFooter = document.getElementById('app-footer'); const rankingBtn = document.getElementById('ranking-btn'); document.title = `${appInfo.title} v${appInfo.version}`; if (headerTitleEl) headerTitleEl.innerHTML = `${appInfo.title} <span class="text-base align-middle text-gray-400 font-medium">v${appInfo.version}</span>`; if (rankingBtn) rankingBtn.innerHTML = uiMessages.moreOptions.ranking; if (appFooter) { const { copyrightYear, authorName, authorLink } = appInfo.footer; appFooter.innerHTML = `Â© ${copyrightYear} <a href="${authorLink}" target="_blank" class="hover:underline">${authorName}</a>. All Rights Reserved. <span class="mx-2">|</span> <a href="#" id="contact-link" class="hover:underline">è¯çµ¡æˆ‘å€‘</a>`; } }
