// gmain.bundle.js - All-in-one compatible bundle for GoddeSpark

// --- Firebase CDN Imports ---
import { getFirestore, collection, doc, setDoc, deleteDoc, onSnapshot, getDoc, getDocs, query, limit, runTransaction, increment, collectionGroup, orderBy, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getStorage, ref, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

// --- Start of app-config.js ---
const appInfo = { title: "女神慾見GoddeSpark", version: "1.6.62", footer: { copyrightYear: "2025", authorName: "LayorX", authorLink: "https://layorx.github.io" } };
const serviceKeys = { firebaseConfig: { apiKey: "AIzaSyDbWa8TWru1J048WK8msVBaC9JhhhtuhJw", authDomain: "goddess-chance.firebaseapp.com", projectId: "goddess-chance", storageBucket: "goddess-chance.appspot.com", messagingSenderId: "440990936442", appId: "1:440990936442:web:37d864cd13112f14913ac3", measurementId: "G-3HCCT2PFXX" }, defaultApiKey: "AIzaSyAZUc69ryBPqw0Ss2ZV-f4Jg5kP3VjDd0c", formspreeUrl: "https://formspree.io/f/xnnzgpdn" };
const dbCollectionNames = { users: 'users', publicGoddesses: 'public-goddesses', dailyTasks: 'dailyTasks', statistics: 'statistics', userStats: 'userStats', favorites: 'favorites', status: 'status' };

// --- Start of game-config.js ---
const randomNicknames = [ "D槽女神官", "波多野結冰", "吉澤明步兵", "搖桿不是這樣用的", "三上悠亞力山大", "單手玩輔助", "奇怪的知識增加了", "本斥但大", "天使萌新", "專業補魔師", "河北彩花錢", "一鍵繳械", "聖光也治不了你", "楓可憐了", "橋本有碼", "明日花騎兵", "全服我最婆", "顯卡在燃燒", "時間管理大師", "多人運動", "你老婆真好用", "相澤南波灣", "大橋未久等了", "櫻空桃太郎", "神宮寺助我", "這題我會", "不可以色色", "小孩子才做選擇", "人類高品質女性", "身體很誠實", "輸出全靠抖", "進擊的巨乳", "法杖不是那樣用", "奶量即是正義", "坐騎給妳騎", "敗犬女神", "異世界轉生女神", "肥宅快樂姬", "我的很大你忍一下", "絕對領域", "求佛不如求我", "紗倉真痛", "涼森玲夢遊", "我先繳械投降", "壞了，我裝的", "老司姬帶帶我", "電子雞女神", "觀音兵收容所", "女神也會芭比Q", "上上下下左右左右" ];
const announcementSettings = { enabled: true, checkLocalStorage: true, pages: [ { title: "🎉 扭蛋狂歡 & 懸賞獵人計畫！ 🎉", message: `<p class="mb-4">Hey！各位神級製造師！準備好迎接一場靈魂的風暴了嗎？</p><p class="mb-3"><strong>【限時扭蛋大放送！】</strong><br>每日扭蛋次數瘋狂飆升到 <strong>20 次</strong>！快來看看誰是真正的天選之人！</p><p class="mb-3"><strong>【Bug 懸賞令！】</strong><br>發現任何 Bug 或鬼點子，馬上回報，至少 <strong>10 次</strong> 扭蛋機會直接入帳！</p><p><strong>【女神星探計畫！】</strong><br>成功分享你的女神到各大社群？快來填寫<a href="https://forms.gle/JXdobEdAa8is2wyR6" target="_blank" class="font-bold text-amber-300 hover:underline">>>>這個神秘表單<<<</a>，證明你的貢獻，我們將用至少 <strong>30 次</strong> 扭蛋機會淹沒你！</p>` }, { title: `🔧 版本 v${appInfo.version} 更新資訊 🔧`, message: `<p class="mb-3">我們很高興帶來這次的更新，主要新增了社群互動功能：</p><ul class="list-disc list-inside space-y-2"><li><strong>女神遇見升級：</strong>更多元化，降低敏感封鎖(使用白天風格更不容易)。</li><li><strong>全新「排行榜」頁面：</strong>現在你可以從主頁進入榮譽殿堂，查看各路好手的排名！</li><li><strong>扭蛋卡片優化：</strong>現在抽卡時會直接顯示該女神的受歡迎程度（讚/倒讚數）。</li><li><strong>暱稱系統實裝：</strong>你可以在「個人化設定」中設定你的專屬暱稱，它將會顯示在排行榜和主頁上。</li><li><strong>UI/UX 優化：</strong>修復了數個已知的 Bug，並對介面進行了微調，提升整體使用體驗。</li></ul><p class="mt-4">感謝您的支持，祝您遊戲愉快！</p>` } ] };
const gameSettings = { dailyLimits: { generateOne: 20, generateFour: 2, gacha: 20, tts: 3, }, gachaStreakGoal: 2, gachaQueryLimit: 100, dislikeMilestones: { 1: "「一道質疑的目光投來...」 (第一票)", 3: "「人群中開始出現竊竊私語...」 (第三票)", 10: "「女神的神性似乎產生了動搖！」 (第十票)", } };
const userStatsStructure = { likes: 0, unlikes: 0, shares: 0, gachaDraws: 0, gachaDislikes: 0, generateOne: 0, generateFour: 0, apiImports: 0, storyGenerations: 0, ttsGenerations: 0, totalGenerations: 0, };
const imageSettings = { resizedSuffix: '_200x300', resizedExtension: '.jpeg' };
const apiSettings = { imageGenerationRetries: 3, imageGenerationDelay: 1000, ttsVoice: "Sulafat", prompts: { imagePrefix: "masterpiece, best quality, ultra-detailed, photorealistic, 8k, sharp focus, detailed beautiful face.", imageSuffix: "aspect ratio 2:3, raw style.", negativePrompt: "ugly, blurry, bad anatomy, disfigured, poorly drawn face, mutation, mutated, extra limb, dull eyes, bad hands, missing fingers, low quality, jpeg artifacts, text, watermark, signature, cartoon, 3d, deformed.", story: (title, description) => `以繁體中文，為一張風格為「${title}」的女性照片融合${description}，寫一段約150字的短篇故事或情境描述。請用充滿想像力且感性的筆觸，描述她的背景、心情或一個正在發生的瞬間。`, tts: (text) => `Say in a gentle and alluring female voice: ${text}` } };
const uiSettings = { enableLoadingAnimation: true, hideLoadingOnConnect: false, loadingScreenDuration: 3000, previewImages: [ 'gimages/g/g1.jpg', 'gimages/g/g2.jpg', 'gimages/g/g3.jpg', 'gimages/g/g4.jpg', 'gimages/g/g5.jpg', 'gimages/g/g6.jpg', 'gimages/g/g7.jpg', 'gimages/g/g8.jpg', 'gimages/g/g9.jpg' ], loadingSilhouettes: [ 'gimages/g/g1.jpg', 'gimages/g/g2.jpg', 'gimages/g/g3.jpg', 'gimages/g/g4.jpg', 'gimages/g/g5.jpg', 'gimages/g/g6.jpg', 'gimages/g/g7.jpg', 'gimages/g/g8.jpg', 'gimages/g/g9.jpg', 'gimages/g/g10.jpg', 'gimages/g/g11.jpg', 'gimages/g/g12.jpg' ], loadingPetalCount: 60, cardRevealDelay: 1, loadingAnimationStep: 1, slideshowTransitionSpeed: 250, swipeThreshold: 50, messageBoxTimeout: 3000, };
const uiMessages = { settingsModal: { title: "個人化設定", imageQualityTitle: "圖片顯示品質", qualityThumbnail: "縮圖優先 (預設)", qualityThumbnailDesc: "優先載入縮圖，點擊後顯示原圖，速度最快。", qualityOriginal: "原圖優先", qualityOriginalDesc: "所有圖片直接載入高解析度原圖，畫質最佳但較耗流量。", settingSaved: "設定已儲存！", nicknameTitle: "您的暱稱", nicknamePlaceholder: "請輸入您喜歡的暱稱...", nicknameSave: "儲存", }, moreOptions: { ranking: "🏆 排行榜", settings: "⚙️ 個人化設定", announcement: "📢 查看公告", about: "關於作品", contact: "聯絡我 (報錯、建議)", apiKey: "匯入 Gemini API Key", }, announcement: { dontShowToday: "今天不再顯示" }, loading: { connecting: "正在連接雲端...", summoning: "正在從雲端神殿召喚女神...", starting: "邂逅即將開始..." }, gachaModalTitle: "命運的邂逅", storyModalTitle: "女神的篇章", buttons: { generateOne: "遇見一位", generateFour: "遇見四位", favorites: "女神殿堂", gacha: "女神扭蛋 🎰", gachaDraw: "召喚", ttsPlay: "聆聽故事", ttsStop: "停止播放", ttsLimit: "明日再來" }, generateLimit: { title: "今日靈感已耗盡", message: "免費生成次數已用完。您可以點擊「更多選項」匯入自己的 Gemini API Key 來繼續無限暢遊！" }, favorites: { emptyTitle: "殿堂還是空的", emptySubtitle: "快去收藏您心儀的女神吧！", empty: "您的女神殿堂還是空的喔！", addSuccess: "收藏成功！", addFailure: "收藏失敗", removeSuccess: "已從殿堂移除。", removeFailure: "取消收藏失敗", uploading: "正在上傳至雲端...", shareFirst: "請先收藏此女神才能分享！" }, gacha: { placeholder: "點擊下方按鈕，遇見一位來自他人宇宙的女神", drawFailed: "召喚失敗", poolEmpty: "獎池是空的！快去分享一些女神吧！", alreadyShared: "這位女神已經在公開殿堂中了！", shareSuccess: "分享成功！獲得一次額外召喚機會！", comingSoon: "還在「濕」工中... 敬請期待！", gachaZeroHint: "靈魂石用光了？分享殿堂中的女神、或回報 Bug/建議都能獲得補充，也可以等待明日重置喔！" }, errors: { firebaseInit: "Firebase 初始化失敗，請檢查設定", cloudConnect: "無法連接雲端，部分功能將受限", syncFavorites: "無法同步雲端收藏", imageLoad: "這張圖片的資料似乎遺失了", ttsFailed: "語音功能暫時無法使用", storyFailed: "故事的靈感暫時枯竭了，請稍後再試。" } };
const soundSettings = { masterVolume: -10, };
const styles = [ { "id": "vip-exclusive", "title": "👑 VIP 專屬", "description": "獨一無二，只能在命運的邂逅中偶遇的稀有女神", "prompt": "A fateful encounter with a legendary, rare goddess. Her presence is utterly unique, and a hint of curiosity in her gaze suggests she was waiting just for you." }, { "id": "beach-silhouette", "title": "🏖️ 夏日戀曲", "description": "海灘、性感，融化你心的夏日海灘戀曲", "prompt": "夏日豔陽海邊的沙灘，一位符合海邊辣妹的穿著(可以是比基尼、或是更吸引男人目光的海邊服裝)，對鏡頭展現熱情與互動。背景是蔚藍的海洋和金色的沙灘，陽光灑在她的身上，營造出一種熱情洋溢、充滿活力的氛圍。", }, { "id": "morning-lazy", "title": "☀️ 晨光私房", "description": "慵懶、私密、屬於你的女友感瞬間", "prompt": "清晨陽光隙灑在凌亂的大床上，一位身材曲線玲瓏、散發慵懶氣息的亞洲模特在床上。她僅穿著一件寬大的男友襯衫，釦子半開，眼神惺忪迷濛，翻來覆去對鏡頭撒嬌充滿私密的女友感與親密氛圍。", }, { "id": "neon-noir", "title": "💦 濕身魅魔", "description": "霓虹、慾望、無法抗拒的危險魅力", "prompt": "在大雨滂沱的城市巷弄中，一位高挑、狂野的亞洲惡女模特。被大雨淋濕，衣服濕透依稀可見內搭，背景是模糊閃爍的霓虹燈，倒映在濕滑的地面上。她的眼神充滿了挑釁與自信，散發著無法抗拒的危險魅力，畫面充滿不安與動感。", }, { "id": "cyberpunk-warrior", "title": "🤖 賽博龐克戰姬", "description": "未來、科技、堅毅眼神中的致命吸引力", "prompt": "(賽博龐克風格)在一座充滿飛行載具與參天大樓的未來城市中，一名身穿發光機械戰甲的亞洲女戰士，手持能量武器，眼神堅毅，剛打玩一場戰役或是跟怪獸廝殺完。展現出致命的吸引力，氣勢充滿英雄氣概與壓迫感。", }];
const randomKeywords_night = { /* ... Omitted for brevity ... */ };
const randomKeywords_day = { /* ... Omitted for brevity ... */ };

// --- Start of stateManager.js ---
let _state = {};
const _subscribers = {};
function initState(initialState) { _state = initialState; console.log("State Manager initialized with:", _state); }
function getState(...keys) { if (keys.length === 1) { return _state[keys[0]]; } const requestedState = {}; for (const key of keys) { if (key in _state) { requestedState[key] = _state[key]; } else { console.warn(`[State Manager] Attempted to get non-existent state key: "${key}"`); } } return requestedState; }
function setState(newState) { for (const key in newState) { if (Object.prototype.hasOwnProperty.call(newState, key)) { if (_state[key] !== newState[key]) { _state[key] = newState[key]; if (_subscribers[key]) { _subscribers[key].forEach(callback => { try { callback(_state[key]); } catch (e) { console.error(`[State Manager] Error in subscriber for key "${key}":`, e); } }); } } } } }
function subscribe(key, callback) { if (!_subscribers[key]) { _subscribers[key] = []; } _subscribers[key].push(callback); if (key in _state) { try { callback(_state[key]); } catch (e) { console.error(`[State Manager] Error in initial callback for key "${key}":`, e); } } return () => { _subscribers[key] = _subscribers[key].filter(cb => cb !== callback); }; }

// --- Start of state.js ---
function getInitialState() { const storedApiKey = localStorage.getItem('userGeminiApiKey'); const hasUserApiKey = !!storedApiKey; const storedImageQuality = localStorage.getItem('userImageQuality'); const storedNickname = localStorage.getItem('userNickname'); return { isGenerating: false, activeStyleId: styles[0].id, isStoryGenerating: false, isTtsGenerating: false, favorites: null, ownGoddessStreak: 0, touchStartX: 0, touchEndX: 0, currentSlideshowIndex: 0, currentTheme: 'night', userApiKey: storedApiKey || serviceKeys.defaultApiKey, hasUserApiKey: hasUserApiKey, imageQuality: storedImageQuality || 'thumbnail', isAppInitialized: false, userNickname: storedNickname || '', }; }

// --- Start of soundManager.js ---
const dummySound = () => {};
const sounds = { start: dummySound, success: dummySound, tab: dummySound, open: dummySound, like: dummySound, gacha: dummySound, toDay: dummySound, toNight: dummySound, };
let isSoundInitialized = false;
async function initSounds() { if (isSoundInitialized) return; try { await Tone.start(); const mainSynth = new Tone.Synth().toDestination(); const fmSynth = new Tone.FMSynth().toDestination(); const tabSynth = new Tone.Synth().toDestination(); sounds.start = () => fmSynth.triggerAttackRelease("C2", "8n"); sounds.success = () => { mainSynth.triggerAttackRelease("C5", "16n", Tone.now()); mainSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.1); }; sounds.tab = () => tabSynth.triggerAttackRelease("C4", "32n"); sounds.open = () => fmSynth.triggerAttackRelease("A3", "16n"); sounds.like = () => mainSynth.triggerAttackRelease("A5", "32n"); sounds.gacha = () => { const synth = new Tone.PolySynth(Tone.Synth).toDestination(); const now = Tone.now(); synth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n", now); synth.triggerAttackRelease(["F4", "A4", "C5", "E5"], "8n", now + 0.2); synth.triggerAttackRelease(["G4", "B4", "D5", "G5"], "4n", now + 0.4); }; sounds.toDay = () => new Tone.AMSynth().toDestination().triggerAttackRelease("C4", "2n"); sounds.toNight = () => new Tone.FMSynth().toDestination().triggerAttackRelease("G5", "8n"); Tone.Master.volume.value = soundSettings.masterVolume; isSoundInitialized = true; console.log("音效引擎已成功初始化。"); } catch (e) { console.error("無法啟動音效引擎:", e); } }

// --- Start of dailyTaskManager.js ---
class DailyTask {
    constructor(taskName, db, userId) { this.name = taskName; this.db = db; this.userId = userId; this.defaultCount = gameSettings.dailyLimits[taskName]; this.state = { count: this.defaultCount, lastUpdate: null, }; this.docRef = doc(this.db, dbCollectionNames.users, userId, dbCollectionNames.dailyTasks, this.name); this.isInitialized = false; }
    // ✨ FIX: Replaced private field '#' with '_' for compatibility
    async _checkAndSync() { if (this.isInitialized && this.state.lastUpdate === new Date().toISOString().split('T')[0]) { return; } const today = new Date().toISOString().split('T')[0]; const docSnap = await getDoc(this.docRef); if (docSnap.exists()) { const dbState = docSnap.data(); if (dbState.lastUpdate === today) { this.state = dbState; } else { const newCount = Math.max(dbState.count, this.defaultCount); this.state.count = newCount; this.state.lastUpdate = today; await this._save(); } } else { this.state.count = this.defaultCount; this.state.lastUpdate = today; await this._save(); } this.isInitialized = true; }
    async _save() { await setDoc(this.docRef, this.state); }
    async getCount() { await this._checkAndSync(); return this.state.count; }
    async use() { await this._checkAndSync(); if (this.state.count > 0) { this.state.count--; await this._save(); return true; } return false; }
    async add(amount) { await this._checkAndSync(); this.state.count += amount; await this._save(); return this.state.count; }
}
async function migrateOldData(db, userId) { /* ... Omitted for brevity ... */ }
const tasks = {};
async function initDailyTaskManager(firestoreInstance, uid) { if (!firestoreInstance || !uid) { console.error("DailyTaskManager init failed."); return; } const checkRef = doc(firestoreInstance, dbCollectionNames.users, uid, dbCollectionNames.dailyTasks, 'gacha'); const checkSnap = await getDoc(checkRef); if (!checkSnap.exists()) { await migrateOldData(firestoreInstance, uid); } for (const taskName in gameSettings.dailyLimits) { tasks[taskName] = new DailyTask(taskName, firestoreInstance, uid); } }
async function getTaskCount(taskName) { if (!tasks[taskName]) throw new Error(`Task "${taskName}" undefined.`); return tasks[taskName].getCount(); }
async function useTask(taskName) { if (!tasks[taskName]) throw new Error(`Task "${taskName}" undefined.`); return tasks[taskName].use(); }
async function addTaskCount(taskName, amount) { if (!tasks[taskName]) throw new Error(`Task "${taskName}" undefined.`); return tasks[taskName].add(amount); }

// --- Start of analyticsManager.js ---
let analyticsDb, analyticsUserId, statsRef;
async function initAnalyticsManager(firestoreInstance, uid) { analyticsDb = firestoreInstance; analyticsUserId = uid; statsRef = doc(analyticsDb, 'users', analyticsUserId, 'statistics', 'userStats'); const docSnap = await getDoc(statsRef); if (!docSnap.exists()) { const nickname = randomNicknames[Math.floor(Math.random() * randomNicknames.length)]; const userDocRef = doc(analyticsDb, 'users', analyticsUserId); await Promise.all([ setDoc(statsRef, { ...userStatsStructure, firstLogin: serverTimestamp(), lastLogin: serverTimestamp() }), setDoc(userDocRef, { nickname: nickname }) ]); console.log(`Initialized stats for new user ${analyticsUserId} with nickname: ${nickname}`); } else { await setDoc(statsRef, { lastLogin: serverTimestamp() }, { merge: true }); } }
async function incrementStat(fieldsToIncrement) { if (!statsRef) { console.warn("Analytics Manager not initialized."); return; } try { const updatePayload = {}; for (const key in fieldsToIncrement) { if (Object.hasOwnProperty.call(fieldsToIncrement, key)) { updatePayload[key] = increment(fieldsToIncrement[key]); } } await setDoc(statsRef, updatePayload, { merge: true }); } catch (error) { console.error("Error updating stats:", error); } }

// --- Start of gfirebase.js ---
let db, auth, storage, currentUserId;
function initFirebase() { try { const app = initializeApp(serviceKeys.firebaseConfig); auth = getAuth(app); db = getFirestore(app); storage = getStorage(app); console.log("Firebase initialized successfully."); return true; } catch (error) { console.error("Firebase initialization failed:", error); return false; } }
function handleAuthentication(onUserSignedIn) { onAuthStateChanged(auth, (user) => { if (user) { currentUserId = user.uid; if (onUserSignedIn) onUserSignedIn(currentUserId); } else { signInAnonymously(auth).catch((error) => { if (onUserSignedIn) onUserSignedIn(null, error); }); } }); }
function getCurrentUserId() { return currentUserId; }
async function getUserData(db, uid) { if (!uid) return null; const userRef = doc(db, dbCollectionNames.users, uid); const docSnap = await getDoc(userRef); if (docSnap.exists()) { return docSnap.data(); } else { return { nickname: '無名氏' }; } }
async function saveNickname(uid, nickname) { if (!uid) throw new Error("User not signed in."); const userRef = doc(db, dbCollectionNames.users, uid); await setDoc(userRef, { nickname: nickname }, { merge: true }); }
function getResizedImageUrl(originalUrl) { /* ... Omitted for brevity ... */ return originalUrl; }
function listenToFavorites(callback) { if (!currentUserId) return () => {}; const favoritesCol = collection(db, dbCollectionNames.users, currentUserId, dbCollectionNames.favorites); const unsubscribe = onSnapshot(favoritesCol, (snapshot) => { const newFavorites = snapshot.docs.map(doc => { const data = doc.data(); return { ...data, resizedUrl: getResizedImageUrl(data.imageUrl) }; }); callback(newFavorites); }, (error) => { console.error("Error listening to favorites:", error); callback([], error); }); return unsubscribe; }
async function saveFavorite(favoriteData) { if (!currentUserId) throw new Error("User not signed in."); const favoriteRef = doc(db, dbCollectionNames.users, currentUserId, dbCollectionNames.favorites, favoriteData.id); await setDoc(favoriteRef, { id: favoriteData.id, style: favoriteData.style, imageUrl: favoriteData.imageUrl }); }
async function removeFavorite(favoriteToRemove) { if (!currentUserId) throw new Error("User not signed in."); const favoriteRef = doc(db, dbCollectionNames.users, currentUserId, dbCollectionNames.favorites, favoriteToRemove.id); await deleteDoc(favoriteRef); }
async function uploadImage(base64String, imageId) { if (!currentUserId) throw new Error("User not signed in."); const storageRef = ref(storage, `${dbCollectionNames.users}/${currentUserId}/images/${imageId}.png`); const snapshot = await uploadString(storageRef, base64String, 'data_url'); return await getDownloadURL(snapshot.ref); }
async function shareToPublic(publicData) { if (!currentUserId) throw new Error("User not signed in."); const publicRef = doc(db, dbCollectionNames.publicGoddesses, publicData.id); const docSnap = await getDoc(publicRef); if (docSnap.exists()) { return { alreadyExists: true }; } await setDoc(publicRef, { id: publicData.id, style: publicData.style, imageUrl: publicData.imageUrl, sharedBy: currentUserId }); return { alreadyExists: false }; }
async function updatePublicGoddessVote(goddessId, voterId, action) { /* ... Omitted for brevity ... */ }
async function addDislikeToGoddess(goddessId, dislikerId) { /* ... Omitted for brevity ... */ }
async function getRandomGoddessFromDB() { const q = query(collection(db, dbCollectionNames.publicGoddesses), limit(gameSettings.gachaQueryLimit)); const snapshot = await getDocs(q); if (snapshot.empty) { throw new Error("獎池是空的！"); } const allDocs = snapshot.docs; const randomIndex = Math.floor(Math.random() * allDocs.length); const data = allDocs[randomIndex].data(); return { ...data, resizedUrl: getResizedImageUrl(data.imageUrl) }; }
async function getRandomGoddessesFromDB(count) { const q = query(collection(db, dbCollectionNames.publicGoddesses), limit(gameSettings.gachaQueryLimit)); const snapshot = await getDocs(q); if (snapshot.empty) { return []; } const allDocs = snapshot.docs.map(doc => { const data = doc.data(); return { ...data, resizedUrl: getResizedImageUrl(data.imageUrl) }; }); const shuffled = allDocs.sort(() => 0.5 - Math.random()); return shuffled.slice(0, count); }

// --- Start of api.js ---
function getRandomItems(arr, count) { const shuffled = [...arr].sort(() => 0.5 - Math.random()); return shuffled.slice(0, count); }
async function generateImageWithRetry(prompt) { /* ... Omitted for brevity ... */ }
async function callImageGenerationAPI(userPrompt, model) { const userApiKey = getState('userApiKey'); const modelName = model === 'imagen-3' ? 'imagen-3.0-generate-002' : 'gemini-2.0-flash-preview-image-generation'; const isImagen = model === 'imagen-3'; const apiUrl = isImagen ? `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:predict?key=${userApiKey}` : `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${userApiKey}`; const payload = isImagen ? { instances: [{ prompt: userPrompt }], parameters: { "sampleCount": 1 } } : { contents: [{ parts: [{ text: userPrompt }] }], generationConfig: { responseModalities: ['TEXT', 'IMAGE'] }, }; const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!response.ok) { const errorData = await response.json(); const errorMessage = errorData && errorData.error ? errorData.error.message : response.statusText; throw new Error(`API 請求失敗: ${errorMessage}`); } const result = await response.json(); if (isImagen) { const base64Data = result && result.predictions && result.predictions.length > 0 ? result.predictions[0].bytesBase64Encoded : null; if (!base64Data) { throw new Error("Imagen API 回應中找不到圖片資料。"); } return `data:image/png;base64,${base64Data}`; } const candidate = result && result.candidates && result.candidates.length > 0 ? result.candidates[0] : null; if (!candidate) { throw new Error("API 回應無效，找不到候選項目。"); } if (candidate.finishReason && candidate.finishReason !== 'STOP') { throw new Error(`圖片生成因安全限制被阻擋，請嘗試更換提示詞。`); } const imagePart = candidate && candidate.content && candidate.content.parts ? candidate.content.parts.find(p => p.inlineData) : null; const base64Data = imagePart && imagePart.inlineData ? imagePart.inlineData.data : null; if (!base64Data) { throw new Error("API 回應中找不到圖片資料。"); } return `data:image/png;base64,${base64Data}`; }
async function callTextGenerationAPI(prompt) { /* ... Omitted for brevity ... */ }
async function callTTSAPI(text) { /* ... Omitted for brevity ... */ }

// --- Start of gui.js ---
const favoritesCountEl = document.getElementById('favorites-count');
const messageBox = document.getElementById('message-box');
function showMessage(text, isError = false) { messageBox.textContent = text; messageBox.style.backgroundColor = isError ? '#E11D48' : '#EC4899'; messageBox.classList.add('show'); setTimeout(() => messageBox.classList.remove('show'), 3000); }
function updateFavoritesCountUI(count) { if (favoritesCountEl) { favoritesCountEl.textContent = count; } }
function createImageCard(imageData, handlers, options = {}) { const { withAnimation = true, withButtons = true } = options; const { style, id, isLiked, isShared, isShareable = true, isGachaCard = false, likeCount = 0, dislikeCount = 0, userHasDisliked = false } = imageData; const displaySrc = imageData.resizedUrl || imageData.imageUrl || imageData.src; const originalSrc = imageData.imageUrl || imageData.src; const imageCard = document.createElement('div'); imageCard.className = 'image-card'; imageCard.dataset.id = id; imageCard.dataset.originalSrc = originalSrc; const dislikeButtonText = userHasDisliked ? '已評價 ✅' : '我覺得不行!...👎'; const dislikeButtonDisabled = userHasDisliked ? 'disabled' : ''; let statsTagsHTML = ''; if (isGachaCard && (likeCount > 0 || dislikeCount > 0)) { statsTagsHTML = `<div class="stats-tags-container">${likeCount > 0 ? `<span class="stat-tag like-tag">❤️ ${likeCount}</span>` : ''}${dislikeCount > 0 ? `<span class="stat-tag dislike-tag">👎 ${dislikeCount}</span>` : ''}</div>`; } const mainButtonHTML = isGachaCard ? `<button class="dislike-btn story-btn" ${dislikeButtonDisabled}>${dislikeButtonText}</button>` : `<button class="story-btn">生成故事 ✨</button>`; const footerHTML = withButtons ? `<div class="card-footer">${mainButtonHTML}<div class="card-actions">${isShareable && !isGachaCard ? `<button class="share-btn ${isShared ? 'shared' : ''}" title="分享至公開殿堂">🌐</button>` : ''}<button class="like-btn ${isLiked ? 'liked' : ''}" title="收藏至私人殿堂">♥</button></div></div>` : ''; const imageWrapperContent = `<img alt="${style ? style.title : 'Gacha Image'}" loading="lazy">${statsTagsHTML}`; if (withAnimation) { imageCard.innerHTML = `<div class="flipper"><div class="card-face card-front"><div class="loader"></div></div><div class="card-face card-back"><div class="image-card-img-wrapper">${imageWrapperContent}</div>${footerHTML}</div></div>`; } else { imageCard.style.opacity = '1'; imageCard.style.animation = 'none'; imageCard.style.position = 'relative'; imageCard.innerHTML = `<div class="image-card-img-wrapper" style="width: 100%; height: 100%;"><img alt="${style ? style.title : 'Gacha Image'}" loading="lazy" style="width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.5s;">${statsTagsHTML}</div>${footerHTML}`; } const img = imageCard.querySelector('img'); img.onload = () => { if (withAnimation) { const flipper = imageCard.querySelector('.flipper'); setTimeout(() => { flipper.classList.add('reveal'); }, 50); } else { img.style.opacity = '1'; } }; img.onerror = function() { /* ... Omitted for brevity ... */ }; if (withButtons) { imageCard.addEventListener('click', (e) => { const clickedCard = e.currentTarget; if (e.target.closest('.story-btn') && !e.target.closest('.dislike-btn')) { e.stopPropagation(); if (id === 'vip-placeholder') { showMessage('此為預覽卡片，無法生成故事喔！'); return; } handlers.onStory(style); } else if (e.target.closest('.dislike-btn')) { e.stopPropagation(); handlers.onDislike(imageData, e.target.closest('.dislike-btn')); } else if (e.target.closest('.like-btn')) { e.stopPropagation(); handlers.onLike(imageData, e.target.closest('.like-btn')); } else if (e.target.closest('.share-btn')) { e.stopPropagation(); handlers.onShare(imageData, e.target.closest('.share-btn')); } else if (e.target.closest('.image-card-img-wrapper')) { handlers.onImageClick(clickedCard); } }); } else { imageCard.addEventListener('click', (e) => { const clickedCard = e.currentTarget; if (e.target.closest('.image-card-img-wrapper')) { handlers.onImageClick(clickedCard); } }); } img.src = displaySrc; return imageCard; }
let particlesArray;
class Particle { constructor(x, y, dX, dY, s, c) { this.x=x;this.y=y;this.directionX=dX;this.directionY=dY;this.size=s;this.color=c; } draw() { const ctx = document.getElementById('background-canvas').getContext('2d'); ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false); ctx.fillStyle = this.color; ctx.fill(); } update() { const canvas = document.getElementById('background-canvas'); if(this.x > canvas.width || this.x < 0) this.directionX = -this.directionX; if(this.y > canvas.height || this.y < 0) this.directionY = -this.directionY; this.x += this.directionX; this.y += this.directionY; this.draw(); } }
function initParticles() { const canvas = document.getElementById('background-canvas'); if (!canvas) return; canvas.width = innerWidth; canvas.height = innerHeight; particlesArray = []; let num = (canvas.height * canvas.width) / 9000; for (let i = 0; i < num; i++) { let size = (Math.random() * 2) + 1; let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2); let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2); let dX = (Math.random() * .4) - .2; let dY = (Math.random() * .4) - .2; particlesArray.push(new Particle(x, y, dX, dY, size, 'rgba(139, 92, 246, 0.3)')); } }
function animateParticles() { const canvas = document.getElementById('background-canvas'); if (!canvas) return; const ctx = canvas.getContext('2d'); requestAnimationFrame(animateParticles); ctx.clearRect(0, 0, innerWidth, innerHeight); if(particlesArray) { for (let i = 0; i < particlesArray.length; i++) { particlesArray[i].update(); } } }
window.addEventListener('resize', () => { initParticles(); });
class Petal { constructor(c) { this.canvas = c; this.x = Math.random()*c.width; this.y = Math.random()*c.height*2-c.height; this.w = 20+Math.random()*15; this.h = 15+Math.random()*10; this.opacity = this.w/35; this.xSpeed = 1+Math.random(); this.ySpeed = .5+Math.random()*.5; this.flip = Math.random(); this.flipSpeed = Math.random()*.03; } draw() { const ctx = this.canvas.getContext('2d'); if(this.y > this.canvas.height || this.x > this.canvas.width){this.x=-this.w; this.y=Math.random()*this.canvas.height*2-this.canvas.height;} ctx.globalAlpha = this.opacity; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.bezierCurveTo(this.x+this.w/2, this.y-this.h/2, this.x+this.w, this.y, this.x+this.w/2, this.y+this.h/2); ctx.closePath(); const grad = ctx.createLinearGradient(this.x, this.y, this.x+this.w, this.y+this.h); grad.addColorStop(0, 'rgba(255,192,203,.8)'); grad.addColorStop(1, 'rgba(236,72,153,.5)'); ctx.fillStyle = grad; ctx.fill(); } animate() { this.x+=this.xSpeed; this.y+=this.ySpeed; this.flip+=this.flipSpeed; this.draw(); } }
function resizeLoadingCanvas(c) { if (!c) return; c.width=window.innerWidth; c.height=window.innerHeight; }
function animateLoading(c, p, o) { if (!c || !o || o.classList.contains('hidden')) return; const ctx = c.getContext('2d'); ctx.clearRect(0,0,c.width,c.height); p.forEach(petal => petal.animate()); requestAnimationFrame(() => animateLoading(c, p, o)); }

// --- Start of handlers.js ---
function generateUniqueId() { return Date.now().toString(36) + Math.random().toString(36).substring(2); }
function base64ToArrayBuffer(base64) { const binaryString = window.atob(base64); const len = binaryString.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); } return bytes.buffer; }
function pcmToWav(pcmData, sampleRate) { /* ... Omitted for brevity ... */ return new Blob([], {type: 'audio/wav'}); }
async function handleImageGeneration(count = 1) { /* ... Omitted for brevity ... */ }
async function handleDislike(imageData, btn) { /* ... Omitted for brevity ... */ }
function getCardHandlers() { return { onStory: handleStoryGeneration, onLike: (imageData, btn) => toggleFavorite(imageData, btn), onShare: shareFavoriteToPublicHandler, onImageClick: (cardElement) => { const originalSrc = cardElement.dataset.originalSrc; const modalImage = document.getElementById('modal-image'); const imageModal = document.getElementById('image-modal'); modalImage.src = originalSrc; imageModal.classList.add('show'); }, onDislike: handleDislike }; }
async function handleStoryGeneration(style) { /* ... Omitted for brevity ... */ }
async function handleTTSGeneration(text) { /* ... Omitted for brevity ... */ }
async function toggleFavorite(imageData, btn) { if (imageData.id === 'vip-placeholder') { showMessage('此為預覽卡片，無法收藏喔！'); return; } const favorites = getState('favorites'); const currentUserIdValue = getCurrentUserId(); if (favorites === null || !currentUserIdValue) { showMessage("雲端資料同步中或尚未登入，請稍候再試...", true); return; } sounds.like(); if (btn) btn.disabled = true; const index = favorites.findIndex(fav => fav && fav.id === imageData.id); if (index > -1) { incrementStat({ unlikes: 1 }); try { await removeFavorite(favorites[index]); await updatePublicGoddessVote(imageData.id, currentUserIdValue, 'unlike'); } catch (error) { console.error("Failed to remove favorite:", error); showMessage(uiMessages.favorites.removeFailure, true); } } else { incrementStat({ likes: 1 }); try { let favoriteData; if (imageData.src && imageData.src.startsWith('data:image')) { showMessage(uiMessages.favorites.uploading); const downloadURL = await uploadImage(imageData.src, imageData.id); favoriteData = { id: imageData.id, style: imageData.style, imageUrl: downloadURL }; } else { favoriteData = { id: imageData.id, style: imageData.style, imageUrl: imageData.imageUrl }; } await saveFavorite(favoriteData); await updatePublicGoddessVote(imageData.id, currentUserIdValue, 'like'); showMessage(uiMessages.favorites.addSuccess); const cardExists = document.querySelector(`.image-card[data-id="${imageData.id}"]`); if (!cardExists && imageData.style && imageData.style.id) { const gallery = document.getElementById(`${imageData.style.id}-gallery`); if (gallery) { const newCardData = { ...imageData, isLiked: true }; const newCard = createImageCard(newCardData, getCardHandlers()); gallery.appendChild(newCard); } } } catch (error) { console.error("Failed to save favorite:", error); showMessage(`${uiMessages.favorites.addFailure}: ${error.message}`, true); } } if (btn) btn.disabled = false; }
async function shareFavoriteToPublicHandler(imageData, btn) { /* ... Omitted for brevity ... */ }
async function unfavoriteCurrentSlide() { /* ... Omitted for brevity ... */ }
async function drawGacha() { /* ... Omitted for brevity ... */ }

// --- Start of uiManager.js ---
let DOMElements = {};
let currentAnnouncementPage = 0;
function initializeUI() { DOMElements = { headerTitle: document.getElementById('header-title'), storyModalTitle: document.getElementById('story-modal-title'), gachaModalTitle: document.getElementById('gacha-modal-title'), tabNavigation: document.getElementById('tab-navigation'), styleSectionsContainer: document.getElementById('style-sections'), generateOneBtn: document.getElementById('generate-one-btn'), generateFourBtn: document.getElementById('generate-four-btn'), gachaBtn: document.getElementById('gacha-btn'), gachaDrawBtn: document.getElementById('gacha-draw-btn'), gachaUnlockInfo: document.getElementById('gacha-unlock-info'), ttsBtn: document.getElementById('tts-btn'), ttsStopBtn: document.getElementById('tts-stop-btn'), ttsLimitInfo: document.getElementById('tts-limit-info'), ttsAudio: document.getElementById('tts-audio'), favoritesBtn: document.getElementById('favorites-btn'), favoritesBtnText: document.getElementById('favorites-btn-text'), slideshowModal: document.getElementById('slideshow-modal'), slideshowImage: document.getElementById('slideshow-image'), thumbnailBar: document.getElementById('thumbnail-bar'), slideshowContainer: document.getElementById('slideshow-container'), favoritesEmptyState: document.getElementById('favorites-empty-state'), themeSwitchBtn: document.getElementById('theme-switch-btn'), sunIcon: document.getElementById('sun-icon'), moonIcon: document.getElementById('moon-icon'), soundControl: document.getElementById('sound-control'), soundOnIcon: document.getElementById('sound-on-icon'), soundOffIcon: document.getElementById('sound-off-icon'), moreOptionsBtn: document.getElementById('more-options-btn'), moreOptionsMenu: document.getElementById('more-options-menu'), settingsBtn: document.getElementById('settings-btn'), aboutBtn: document.getElementById('about-btn'), contactBtn: document.getElementById('contact-btn'), apikeyBtn: document.getElementById('apikey-btn'), gachaModal: document.getElementById('gacha-modal'), gachaCloseBtn: document.getElementById('gacha-close-btn'), storyModal: document.getElementById('story-modal'), imageModal: document.getElementById('image-modal'), apikeyModal: document.getElementById('apikey-modal'), apikeyModalContent: document.getElementById('apikey-modal-content'), contactModal: document.getElementById('contact-modal'), contactModalContent: document.getElementById('contact-modal-content'), comingSoonModal: document.getElementById('coming-soon-modal'), comingSoonModalContent: document.getElementById('coming-soon-modal-content'), settingsModal: document.getElementById('settings-modal'), settingsModalContent: document.getElementById('settings-modal-content'), announcementModal: document.getElementById('announcement-modal'), announcementModalContent: document.getElementById('announcement-modal-content'), userInfo: document.getElementById('user-info'), rankingBtn: document.getElementById('ranking-btn'), announcementOpenBtn: document.getElementById('announcement-open-btn'), }; setupUIText(); createTabsAndSections(); addEventListeners(); setupSubscriptions(); }
function setupUIText() { /* ... Omitted for brevity ... */ }
function createTabsAndSections() { styles.forEach((style, index) => { const tabButton = document.createElement('button'); tabButton.className = `tab-button text-md font-medium py-2 px-4 text-gray-400 ${index === 0 ? 'active' : ''}`; tabButton.textContent = style.title; tabButton.dataset.target = `content-${style.id}`; tabButton.dataset.styleId = style.id; DOMElements.tabNavigation.appendChild(tabButton); const section = document.createElement('section'); section.id = `content-${style.id}`; section.className = `tab-content ${index === 0 ? 'active' : ''}`; section.innerHTML = `<div class="text-center mb-8 mt-4"><p class="text-gray-400 mt-1">${style.description}</p></div><div id="${style.id}-gallery" class="card-container mb-8"></div>`; DOMElements.styleSectionsContainer.appendChild(section); }); }
function addEventListeners() { /* ... Omitted for brevity ... */ }
function setupSubscriptions() { subscribe('activeStyleId', (styleId) => { document.querySelectorAll('.tab-button').forEach(btn => btn.classList.toggle('active', btn.dataset.styleId === styleId)); document.querySelectorAll('.tab-content').forEach(content => content.classList.toggle('active', content.id === `content-${styleId}`)); updateGenerateButtonsState(); }); subscribe('isGenerating', (isGenerating) => { updateGenerateButtonsState(); }); subscribe('hasUserApiKey', () => { updateAllTaskUIs(); }); subscribe('isStoryGenerating', (isGenerating) => { updateTtsUi(); }); subscribe('isTtsGenerating', (isGenerating) => { DOMElements.ttsBtn.style.display = isGenerating ? 'none' : 'inline-block'; DOMElements.ttsStopBtn.style.display = isGenerating ? 'inline-block' : 'none'; if (!isGenerating) { updateTtsUi(); } else { DOMElements.ttsBtn.textContent = '聲音合成中...'; DOMElements.ttsBtn.disabled = true; } }); }
async function updateAllTaskUIs() { if (!getState('isAppInitialized')) { return; } await updateGenerateButtonsState(); await updateGachaUI(); await updateTtsUi(); }
async function updateGenerateButtonsState() { /* ... Omitted for brevity ... */ }
async function updateGachaUI() { /* ... Omitted for brevity ... */ }
async function updateTtsUi() { /* ... Omitted for brevity ... */ }
function openGachaModal() { /* ... Omitted for brevity ... */ }
function openApiKeyModal() { /* ... Omitted for brevity ... */ }
function openContactModal() { /* ... Omitted for brevity ... */ }
async function handleContactFormSubmit(e) { /* ... Omitted for brevity ... */ }
function toggleMute() { /* ... Omitted for brevity ... */ }
function toggleTheme() { /* ... Omitted for brevity ... */ }
function openSlideshow() { /* ... Omitted for brevity ... */ }
function updateSlideshowUI(favorites) { /* ... Omitted for brevity ... */ }
function navigateSlideshow(direction) { /* ... Omitted for brevity ... */ }
function showSlide(index) { /* ... Omitted for brevity ... */ }
function renderThumbnails() { /* ... Omitted for brevity ... */ }
function openSettingsModal() { /* ... Omitted for brevity ... */ }
function updateUserInfo(uid, nickname, isConnecting = false) { if (DOMElements.userInfo) { if (isConnecting) { DOMElements.userInfo.innerHTML = `雲端連線中...`; } else if (uid) { const nicknameHTML = nickname ? `<span class="user-nickname">(${nickname})</span>` : ''; DOMElements.userInfo.innerHTML = `雲端使用者 ${nicknameHTML} ID: ${uid}`; } else { DOMElements.userInfo.innerHTML = `雲端使用者 ID: 尚未登入`; } } }
function renderAnnouncementPage(pageIndex) { /* ... Omitted for brevity ... */ }
function openAnnouncementModal(forceShow = false) { if (!announcementSettings.enabled || !announcementSettings.pages || announcementSettings.pages.length === 0) return; if (!forceShow && announcementSettings.checkLocalStorage) { const lastShownDate = localStorage.getItem('announcementLastShown'); const today = new Date().toISOString().split('T')[0]; if (lastShownDate === today) { return; } } currentAnnouncementPage = 0; renderAnnouncementPage(currentAnnouncementPage); DOMElements.announcementModal.classList.add('show'); }

// --- Start of gmain.js (Main Logic) ---
let isLoadingOverlayHidden = false;
function hideLoadingOverlay() { if (isLoadingOverlayHidden) return; const loadingOverlay = document.getElementById('loading-overlay'); if (loadingOverlay) { loadingOverlay.classList.add('hidden'); } if (!getCurrentUserId()) { updateAllTaskUIs(); } openAnnouncementModal(); isLoadingOverlayHidden = true; }
window.onload = () => { initState(getInitialState()); setupAppInfo(); window.firebaseConfig = serviceKeys.firebaseConfig; initializeUI(); setupStateSubscriptions(); updateUserInfo(null, null, true); if (!uiSettings.enableLoadingAnimation) { hideLoadingOverlay(); if (initFirebase()) { handleAuthentication(onUserSignedIn); } else { showMessage(uiMessages.errors.firebaseInit, true); } } else { startLoadingSequence(); if (initFirebase()) { handleAuthentication(onUserSignedIn); } else { showMessage(uiMessages.errors.firebaseInit, true); hideLoadingOverlay(); } } initParticles(); animateParticles(); const startAudioOnce = async () => { await initSounds(); document.body.removeEventListener('click', startAudioOnce); document.body.removeEventListener('touchend', startAudioOnce); }; document.body.addEventListener('click', startAudioOnce); document.body.addEventListener('touchend', startAudioOnce); };
async function onUserSignedIn(uid, error) { if (uid) { const db = getFirestore(initializeApp(serviceKeys.firebaseConfig)); const [_, __, userData] = await Promise.all([ initDailyTaskManager(db, uid), initAnalyticsManager(db, uid), getUserData(db, uid) ]); const nickname = (userData && userData.nickname) ? userData.nickname : ''; updateUserInfo(uid, nickname); setState({ userNickname: nickname }); if (nickname) { localStorage.setItem('userNickname', nickname); } listenToFavorites(onFavoritesUpdate); setState({ isAppInitialized: true }); updateAllTaskUIs(); if (uiSettings.hideLoadingOnConnect) { hideLoadingOverlay(); } } else { showMessage(uiMessages.errors.cloudConnect, true); console.error("Authentication Error:", error); setState({ isAppInitialized: true }); updateUserInfo(null, null, false); if (uiSettings.hideLoadingOnConnect) { hideLoadingOverlay(); } } }
function onFavoritesUpdate(newFavorites, err) { if (err) { showMessage(uiMessages.errors.syncFavorites, true); setState({ favorites: [] }); return; } setState({ favorites: newFavorites }); }
function startLoadingSequence() { const loadingOverlay = document.getElementById('loading-overlay'); const loadingText = document.getElementById('loading-text'); const silhouetteContainer = document.querySelector('.silhouette-container'); const loadingCanvas = document.getElementById('loading-canvas'); if (loadingText) loadingText.textContent = uiMessages.loading.connecting; const silhouettes = [...uiSettings.loadingSilhouettes].sort(() => 0.5 - Math.random()); silhouetteContainer.innerHTML = silhouettes.map(src => `<img src="${src}" class="loading-silhouette" alt="Loading Muse">`).join(''); const silhouetteElements = document.querySelectorAll('.loading-silhouette'); if (silhouetteElements.length > 0) { const animationStep = uiSettings.loadingAnimationStep; const totalDuration = silhouetteElements.length * animationStep; silhouetteElements.forEach((el, index) => { el.style.animationDelay = `${index * animationStep}s`; el.style.animationDuration = `${totalDuration}s`; el.style.animationName = 'silhouette-fade'; }); } resizeLoadingCanvas(loadingCanvas); let petals = Array.from({ length: uiSettings.loadingPetalCount }, () => new Petal(loadingCanvas)); animateLoading(loadingCanvas, petals, loadingOverlay); setTimeout(() => { if (loadingText) loadingText.textContent = uiMessages.loading.starting; setTimeout(() => { hideLoadingOverlay(); if (!getCurrentUserId()) { updateAllTaskUIs(); } openAnnouncementModal(); }, 500); }, uiSettings.loadingScreenDuration); }
async function generateInitialImages(favorites) { for (const fav of favorites) { const displayUrl = fav.resizedUrl || fav.imageUrl; if (!fav || !fav.style || !fav.style.id || !displayUrl) continue; const gallery = document.getElementById(`${fav.style.id}-gallery`); if (gallery) { const imageData = { ...fav, src: displayUrl, isLiked: true }; const imageCard = createImageCard(imageData, getCardHandlers()); gallery.appendChild(imageCard); } } if (favorites.length < 4) { try { const randomGoddesses = await getRandomGoddessesFromDB(4); for (const goddess of randomGoddesses) { if (document.querySelector(`.image-card[data-id="${goddess.id}"]`)) continue; const displayUrl = goddess.resizedUrl || goddess.imageUrl; const gallery = document.getElementById(`${goddess.style.id}-gallery`); if (gallery) { const imageData = { ...goddess, src: displayUrl, isLiked: favorites.some(fav => fav.id === goddess.id) }; const imageCard = createImageCard(imageData, getCardHandlers()); gallery.appendChild(imageCard); } } } catch (error) { console.error("Failed to fetch initial random goddesses:", error); showMessage(error.message, true); } } }
function setupAppInfo() { const headerTitleEl = document.getElementById('header-title'); const appFooter = document.getElementById('app-footer'); const rankingBtn = document.getElementById('ranking-btn'); document.title = `${appInfo.title} v${appInfo.version}`; if (headerTitleEl) headerTitleEl.innerHTML = `${appInfo.title} <span class="text-base align-middle text-gray-400 font-medium">v${appInfo.version}</span>`; if (rankingBtn) rankingBtn.innerHTML = uiMessages.moreOptions.ranking; if (appFooter) { const { copyrightYear, authorName, authorLink } = appInfo.footer; appFooter.innerHTML = `© ${copyrightYear} <a href="${authorLink}" target="_blank" class="hover:underline">${authorName}</a>. All Rights Reserved. <span class="mx-2">|</span> <a href="#" id="contact-link" class="hover:underline">聯絡我們</a>`; } }
